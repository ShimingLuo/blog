{"meta":{"title":"Null.","subtitle":"善战者，不武。","description":"Null,blog,无聊,有趣,有料","author":"Shiming.Luo","url":"http://gavinluo.cn/blog"},"pages":[{"title":"","date":"2017-12-09T11:04:38.663Z","updated":"2017-04-04T23:16:30.000Z","comments":false,"path":"categories/index.html","permalink":"http://gavinluo.cn/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-12-09T11:04:38.663Z","updated":"2017-04-04T23:15:22.000Z","comments":false,"path":"tags/index.html","permalink":"http://gavinluo.cn/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"特别的WebSocket服务器实现--WeSocketed","slug":"特别的WebSocket服务器实现-WeSocketd","date":"2018-01-04T03:10:11.425Z","updated":"2018-01-04T03:12:54.996Z","comments":true,"path":"2018/01/04/特别的WebSocket服务器实现-WeSocketd/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/特别的WebSocket服务器实现-WeSocketd/","excerpt":"","text":"它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。 官网：WeSocketd","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://gavinluo.cn/blog/categories/WebSocket/"}],"tags":[]},{"title":"","slug":"网页截图工具-Pageres","date":"2018-01-04T03:10:11.424Z","updated":"2018-01-04T03:12:54.996Z","comments":true,"path":"2018/01/04/网页截图工具-Pageres/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/网页截图工具-Pageres/","excerpt":"","text":"前言Pageres是一款图片自动抓取工具，通过shell是可以给其他语言调用，比如Node.js。很多网页特别长，直接的电脑截图非常麻烦，用ps等工具也非常麻烦，Pageres可以自动抓出截图。 正文一、软件安装 安装 pageres 时，用于产生截屏的 PhantomJS 会被自动安装；但是也有可能会卡死，或者安装失败，得到错误：Error：spawn EAXXES。如果有这个错误，手动 下载 PhantomJS，然后重新安装。 12345# 提示，如果安装缓慢，需要更换使用淘宝镜像资源# 全局安装$ npm install --global pageres# 项目安装，并添加依赖$ npm install --save pageres 注意：手动下载PhantomJS安装文件，需要手动配置环境变量 二、使用","categories":[],"tags":[]},{"title":"Express博客系统","slug":"Express博客系统","date":"2018-01-04T03:10:11.422Z","updated":"2017-12-05T13:15:00.000Z","comments":true,"path":"2018/01/04/Express博客系统/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Express博客系统/","excerpt":"","text":"前言简单的Blog 源代码： GitHub 技术基础nodejs安装使用 MpngoDB安装使用 ES6的基础 Express的使用12345678910111213// 简单路由var express = require('express');var app = express();app.get('/', function(req, res) &#123; res.send('hello, express');&#125;);app.get('/users/:name', function(req, res) &#123; res.send('hello, ' + req.params.name);&#125;);app.listen(3000); supervisor自动重启服务工具12345# 安装$ npm install -g supervisor# 启动$ supervisor --harmony index ejs模板引擎1$ npm i ejs --save 使用12345678910111213var path = require('path');var express = require('express');var app = express();var indexRouter = require('./routes/index');var userRouter = require('./routes/users');app.set('views', path.join(__dirname, 'views'));// 设置存放模板文件的目录app.set('view engine', 'ejs');// 设置模板引擎为 ejsapp.use('/', indexRouter);app.use('/users', userRouter);app.listen(3000); 开发环境准备初始化项目文件夹1$ npm init 安装需要的模块：123456789101112131415模块的用处：express: web 框架express-session: session 中间件connect-mongo: 将 session 存储于 mongodb，结合 express-session 使用connect-flash: 页面通知提示的中间件，基于 session 实现ejs: 模板express-formidable: 接收表单及文件的上传中间件config-lite: 读取配置文件marked: markdown 解析moment: 时间格式化mongolass: mongodb 驱动objectid-to-timestamp: 根据 ObjectId 生成时间戳sha1: sha1 加密，用于密码加密winston: 日志express-winston: 基于 winston 的用于 express 的日志中间件 配置文件:12345678910111213/* ./config/default.js */ module.exports = &#123; // 程序启动要监听端口号 port: 3000, // express-session 的配置信息 session: &#123; secret: 'myblog', key: 'myblog', maxAge: 2592000000 &#125;, // mongoDB 的地址，blog 为 DB 名 mongodb: 'mongodb://localhost:27017/blog'&#125;; 开发 精简代码解释 数据库链接，及表的模型设计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 数据库连接var config = require('config-lite')(__dirname);var Mongolass = require('mongolass');var moment = require('moment'); // 格式化时间var objectIdToTimestamp = require('objectid-to-timestamp');var mongolass = new Mongolass();// 根据 id 生成创建时间 created_atmongolass.plugin('addCreatedAt', &#123; afterFind: function (results) &#123; results.forEach(function (item) &#123; item.created_at = moment(objectIdToTimestamp(item._id)).format('YYYY-MM-DD HH:mm'); &#125;); return results; &#125;, afterFindOne: function (result) &#123; if (result) &#123; result.created_at = moment(objectIdToTimestamp(result._id)).format('YYYY-MM-DD HH:mm'); &#125; return result; &#125;&#125;);// 链接数据库mongolass.connect(config.mongodb);// User 模型exports.User = mongolass.model('User', &#123; name: &#123;type: 'string'&#125;, password: &#123;type: 'string'&#125;, avatar: &#123;type: 'string'&#125;, gender: &#123;type: 'string', enum: ['m', 'f', 'x']&#125;, bio: &#123;type: 'string'&#125;&#125;);exports.User.index(&#123;name: 1&#125;, &#123;unique: true&#125;).exec(); // 根据用户名找到用户，用户名全局唯一// 文章模型exports.Post = mongolass.model('Post', &#123; author: &#123; type: Mongolass.Types.ObjectId &#125;, title: &#123; type: 'string' &#125;, content: &#123; type: 'string' &#125;, pv: &#123; type: 'number' &#125;&#125;);exports.Post.index(&#123;author: 1, _id: -1&#125;).exec();// 按创建时间降序查看用户的文章列表，author升序、_id降序// 留言模型exports.Comment = mongolass.model('Comment', &#123; author: &#123; type: Mongolass.Types.ObjectId &#125;, content: &#123; type: 'string' &#125;, postId: &#123; type: Mongolass.Types.ObjectId &#125;&#125;);exports.Comment.index(&#123; postId: 1, _id: 1 &#125;).exec(); // 通过文章 id 获取该文章下所有留言，按留言创建时间升序exports.Comment.index(&#123; author: 1, _id: 1 &#125;).exec(); // 通过用户 id 和留言 id 删除一个留言 用户的Module接口设计处理123456789101112var &#123; User &#125; = require('../lib/mongo');module.exports = &#123; // 注册用户 create: function(user) &#123; return User.create(user).exec(); &#125;, // 根据用户名获取用户信息 getUserByName: function(name) &#123; return User.findOne(&#123; name: name &#125;).addCreatedAt().exec(); &#125;&#125;; 开发过程中，每次修改需要重启，很是麻烦，可以使用 supervisor12345# 全局安装npm install -s supervisor# 监听文件修改后，自动重启服务器supervisor --harmony index.js 部署申请线上 MongoDB 数据存储服务。MLab 申请成功，并创建数据库厚，添加新的配置文件，production.js，使用，NODE_ENV=production 设置配置文件。 windows 下，全局安装 cross-env 模块， cross-env NODE_ENV=production …… 完成后，开始部署服务器（CentOS 64位） 安装环境12345678910yum install git #安装gityum install nodejs #安装 Node.jsyum install npm #安装 npmnpm i npm -g #升级 npmnpm i pm2 -g #安装 pm2npm i n -g #安装 n# n v6.9.1 #安装 v6.9.1 版本的 Node.js# n use 6.9.1 #使用 v6.9.1 版本的 Node.jsnode -v 这个时候，有可能安装都不成功哦。比如我的ContOS就是，安装Node不成功，当时是修改咯Node的源成功的 当然，安装 pm2 的时候成功咯，但是，使用时， pm2 -v 报错？？？没有命令，我就懵逼咯当时。 强行使用12345# linux下which node# windows下where node 查看一哈，node的路径，然后并看不出来什么，因为，是快捷方式 cd 到那个目录下后，1ls -l ，看到指向咯，真实的node安装地址，cd 到目录下后，惊呆咯。 安装的都在，访问也能成功，看来是环境变量出问题咯。 原因是我的，node、npm 都是采用离线安装，然后直接用快捷方式放到 bin/ 下，所有没有配置环境变量。 没办法，自己设置咯。123456# 设置只有当前用户生效的环境配置vim ~/.bash_profile# 在path=。。。后面添加需要添加环境变量目录PATH=$PATH:$HOME/bin:/usr/local/src/node-v8.4.0-linux-x86/bin 到此，应该都是成功的咯。 将代码从Git上拉下来，1234567npm installnpm startpm2 logs# pm2 mont 访问。 END","categories":[{"name":"Express","slug":"Express","permalink":"http://gavinluo.cn/blog/categories/Express/"}],"tags":[]},{"title":"VUE初体验","slug":"VUE初体验","date":"2018-01-04T03:10:11.421Z","updated":"2017-11-05T13:15:00.000Z","comments":true,"path":"2018/01/04/VUE初体验/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/VUE初体验/","excerpt":"","text":"VUE简介VUE开发开发环境一、 安装NodeJs 悄悄的安装就好、npm + node 二、 安装VUE官方构建工具—-vue-cli 简介 vue-cli是官方的项目构建工具，一个简单的构建工具，通过几个默认的步骤帮助你快速的构建Vue.js项目。 安装 12# 国内速度的原因，请更换npm镜像npm install -g vue-cli 选择模板 官方项目模板 vuejs-templates 1$ vue init &lt;template-name&gt; &lt;project-name&gt; 也可以是用以下命令来查看官方模板列表： 1$ vue list 目前官方包含可用的： browserify –– 全功能的Browserify + vueify，包括热加载，静态检测，单元测试 browserify-simple –– 一个简易的Browserify + vueify，以便于快速开始。 webpack –– 全功能的Webpack + vueify，包括热加载，静态检测，单元测试 webpack-simple –– 一个简易的Webpack + vueify，以便于快速开始。 simple — 单个HTML文件中最简单的Vue设置 pwa — Vue CLI基于WebPACK模板 第一个项目 初始化项目 1234# 初始化vue init webpack vue-demo# 安装依赖npm install 预览 1$ npm run dev ss","categories":[{"name":"vue","slug":"vue","permalink":"http://gavinluo.cn/blog/categories/vue/"}],"tags":[]},{"title":"电商平台开发（二）","slug":"电商平台开发（二）","date":"2018-01-04T03:10:11.416Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/电商平台开发（二）/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/电商平台开发（二）/","excerpt":"","text":"项目通用功能开发 通用js工具的封装 网络请求：ajax请求、url配置 URL路径工具 模板渲染工具 – hogan 字段验证 &amp;&amp; 通用提示 统一跳转 。。。 界面布局没有设计狮，程序猿。 能爽死强迫症的对齐 你不知道的对称美 扁平化多, 减少代码量美观 保持一定的距离 配色是一门学问，灰色比较白搭（高端灰）","categories":[{"name":"demo","slug":"demo","permalink":"http://gavinluo.cn/blog/categories/demo/"}],"tags":[]},{"title":"NodeJs+PhantomJS获取网站截图","slug":"NodeJs-PhantomJS获取网站截图","date":"2018-01-04T03:10:11.413Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/NodeJs-PhantomJS获取网站截图/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/NodeJs-PhantomJS获取网站截图/","excerpt":"","text":"环境准备NodeJs – 添加环境变量 PhantomJS – 添加环境变量 安装所需库pageres：基于 PhantomJS 的截图库，没有安装 PhantomJS 会自动安装，如果安装失败手动安装就好 12# 安装 pageres$ npm install pageres 使用12345678910const Pageres = require('pageres');const pageres = new Pageres(&#123;delay: 2&#125;) .src('gavinluo.cn', ['480x320', '1024x768', 'iphone 5s'], &#123;crop: true&#125;) .src('gavinluo.cn/gank', ['iphone 5s'], &#123;crop: true&#125;) .src('gavinluo.cn/blog', ['1280x1024', '1920x1080']) .src('data:text/html;base64,PGgxPkZPTzwvaDE+', ['1024x768']) .dest(__dirname) .run() .then(() =&gt; console.log('done'));","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/categories/NodeJs/"}],"tags":[]},{"title":"Gulp配置模板","slug":"Gulp配置模板","date":"2018-01-04T03:10:11.412Z","updated":"2017-01-01T13:15:00.000Z","comments":true,"path":"2018/01/04/Gulp配置模板/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Gulp配置模板/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106'use strict';var gulp = require('gulp'), connect = require('gulp-connect'), proxy = require('http-proxy-middleware');const ROOT_DIR = 'dist/';// servergulp.task('connect', () =&gt; &#123; connect.server(&#123; livereload: true, middleware: (connect, opt) =&gt; &#123; let middle = []; // 解析代理，中间健 middle.push(proxy('/api', &#123; target: 'http://bim.groupinno.com/api', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;)); // 解析代理，中间健 middle.push(proxy('/web', &#123; target: 'http://bim.groupinno.com/web', changeOrigin: true, pathRewrite: &#123; '^/web': '' &#125; &#125;)); return middle; &#125; &#125;);&#125;);// watchgulp.task('watch', () =&gt; &#123; gulp.watch(['**/*.*', '!node_modules/**']).on('change', (event) =&gt; &#123; console.log(new Date().toLocaleTimeString(), event.path, event.type); gulp.src('').pipe(connect.reload()); &#125;);&#125;);/* 资源压缩 */// 处理 *.htmlgulp.task('html', () =&gt; &#123; let htmlmin = require('gulp-htmlmin'); return gulp.src('./*.html').pipe(htmlmin(&#123; collapseWhitespace: false, removeComments: true &#125;)).pipe(gulp.dest(`$&#123;ROOT_DIR&#125;`));&#125;);// 处理 *.cssgulp.task('css', () =&gt; &#123; let minifyCSS = require('gulp-minify-css'); return gulp.src(['./css/*.css']).pipe(minifyCSS()).pipe(gulp.dest(`$&#123;ROOT_DIR&#125;css`));&#125;);// 处理 *.jsgulp.task('js', () =&gt; &#123; let uglify = require('gulp-uglify'); return gulp.src(['./js/*.js']).pipe(uglify(&#123; mangle: true,//类型：Boolean 默认：true 是否修改变量名 compress: true,//类型：Boolean 默认：true 是否完全压缩 &#125;)).pipe(gulp.dest(`$&#123;ROOT_DIR&#125;js`));&#125;);// 移动资源gulp.task('lib', () =&gt; &#123; return gulp.src(['./lib/**']).pipe(gulp.dest(`$&#123;ROOT_DIR&#125;lib`));&#125;);/* 注意 *//* 处理资源的时候，需要 return Stram流直接写入文件。。否则，处理打包，上传需要二次执行任务才能成功，且文件目标文件夹必须纯在 */// 打包压缩gulp.task('build', ['lib', 'html', 'css', 'js']);// 打包文件夹为，ZIP文件gulp.task('zip', ['build'], function () &#123; let zip = require('gulp-zip'); gulp.src(`./$&#123;ROOT_DIR&#125;/**`) .pipe(zip('ucm.zip')) .pipe(gulp.dest('./')) .on('end', () =&gt; &#123; let del = require('del'); del.sync([ROOT_DIR]); &#125;);&#125;);// 压缩后的上传文件到服务器gulp.task('push', ['build'], function () &#123; // 服务器配置 const GulpSSH = require('gulp-ssh'); var gulpSSH = new GulpSSH(&#123; ignoreErrors: false, sshConfig: &#123; host: '47.100.9.3', port: 22, username: 'luoshiming', password: 'qwertyuiop..' &#125; &#125;); return gulp.src([`./$&#123;ROOT_DIR&#125;/**`]) .pipe(gulpSSH.dest(`/projects/GI-X04-Web-pc/ucm/`));&#125;);// live-reloadgulp.task('default', ['connect', 'watch']); #","categories":[{"name":"gulp","slug":"gulp","permalink":"http://gavinluo.cn/blog/categories/gulp/"}],"tags":[]},{"title":"JS下载文件","slug":"JS下载文件","date":"2018-01-04T03:10:11.411Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/JS下载文件/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/JS下载文件/","excerpt":"","text":"前言公司将会话验证改为，在HTTP请求的Header中存入一个Token键值对，以供后台会话是否过期验证。 所以在使用，1&lt;a href=\"/a.jpg\" download=\"test.jpg\"&gt;XXX&lt;/a&gt; 下载文件时会出现请求401，会话过期的情况 抓包后，发现下载请求中没有将我们的 Token 字段传回去。 发现，浏览器在发送请求时，只会自动的将，cookie 中的内容回发回去。 解决方法在 HTTP2.0的时代新增加了一个 new Blob() 容器的概念，所以利用这个，使用js下载文件。 直接上，请求文件返回 Blob 数据流代码：1234567891011121314151617181920212223242526272829303132Tools.ajaxBlob = function (opt) &#123; opt = $.extend(&#123;&#125;, &#123; type: 'get', url: '', data: &#123;&#125;, headers: &#123;&#125;, dataType: 'blob',// blob流返回类型 success: function (data, xhr) &#123;/* ok */&#125; &#125;, opt);// 默认值 opt.headers[\"Token\"] = \"XXXXXX\";// 添加字段 // 验证是否支持 if (typeof history.pushState == \"function\") &#123; var xhr = new XMLHttpRequest(); xhr.open(opt.type, opt.url + \"?\" + $.param(opt.data), true);//jQuery的序列化，并打开请求 for(var key in opt.headers)&#123; xhr.setRequestHeader(key, opt.headers[key]); &#125; xhr.responseType = opt.dataType; // 成功执行 xhr.onload = function (e) &#123; // this == XMLHttpRequest if (this.status == 200) &#123; if(typeof opt.success === 'function')&#123; opt.success(this.response, this); &#125; &#125; &#125;; xhr.send(); &#125;else &#123; console.info('没法'); &#125;&#125;; 为什么不用 jQuery ajax ？ 我咋知道，查完了，jQuery ajax 的文档，发现dataType返回的数据类型中，并没有 Blob 这个类型。（jQuery2版） 将 调用浏览器的下载功能，下载 Blob 流：123456789101112Tools.downBlobFile = function(blob, fileName) &#123; window.URL = window.URL || window.webkitURL; if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName); &#125; else &#123; var link = document.createElement('a'); link.href = window.URL.createObjectURL(blob);//创建 blob的url link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href);// 释放 &#125;&#125;; 注意，需要查看浏览器是否支持的，详见：Can I Use. over","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[]},{"title":"Hexo-and-Github搭建博客","slug":"Hexo-and-Github搭建博客","date":"2018-01-04T03:10:11.410Z","updated":"2017-12-05T13:15:00.000Z","comments":true,"path":"2018/01/04/Hexo-and-Github搭建博客/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Hexo-and-Github搭建博客/","excerpt":"","text":"正文：配置环境 安装Node（官网：https://nodejs.org） 安装Git GitHub账号 安装Hexo Node和Git都安装好后，可以执行 1$ sudo npm install -g hexo 开始使用 创建一个hexo文件夹，cd到文件夹下 1$ hexo init 生成静态页面 1$ hexo generate（或，hexo g） 本地启动预览 12# 启动默认监听端口：4000$ hexo server（或，hexo s） 常见错误 1$ hexo init 配置GitHub12# hexo根目录下的配置文件$ vim _config.yml 定位到，最下（deploy属性），注意：==: 后面需要空格== 1234deploy: type: git repository: https://github.com/ShimingLuo/ShimingLuo.github.io.git #ssh key协议直接上 git@github.com:ShimingLuo/ShimingLuo.github.io.git branch: master 安装支持Git部署插件1$ npm install hexo-deployer-git --save 部署 1$ hexo deploy 总结部署步骤 每次按照三个步骤来12345# 清除原有的、生成、（建议先浏览）、部署$ hexo clean$ hexo generate$ hexo server$ hexo deploy 一些常用的hexo命令 12345678$ hexo version #查看Hexo版本$ hexo help #查看帮助$ hexo new \"postName\" #新建文章$ hexo new page \"pageName\" #新建页面$ hexo clean #清除生成的publick文件$ hexo generate #生成静态页面至publick目录$ hexo server #开启预览访问端口（默认端口4000，'ctrl+c'关闭server）$ hexo deploy #将.deploy目录部署到GitHub","categories":[{"name":"hexo","slug":"hexo","permalink":"http://gavinluo.cn/blog/categories/hexo/"}],"tags":[]},{"title":"","slug":"面试","date":"2018-01-04T03:10:11.408Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/面试/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/面试/","excerpt":"","text":"中级前端工程师，技术需求：https://segmentfault.com/a/1190000002627927","categories":[],"tags":[]},{"title":"小程序入门","slug":"小程序入门","date":"2018-01-04T03:10:11.407Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/小程序入门/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/小程序入门/","excerpt":"","text":"前言开发文档：https://mp.weixin.qq.com/debug/wxadoc/dev/index.html 正文基于微信App的，微信APP Store里的小程序 文件结构小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。 一个小程序主体部分（APP）由三个文件组成，必须放在项目的根目录，如下： 文件 必填 作用 app.js 是 小程序逻辑 app.json 是 小程序公共设置 app.wxss 否 小程序公共样式 一个小程序页面（APP Pages）由四个文件组成，分别是： 文件类型 必填 作用 js 是 页面逻辑 wxml 是 页面结构 wxss 否 页面样式表 json 否 页面配置 注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。 配置使用 app.json 文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 以下是一个带有所有属性的简单配置 app.json :1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;: &#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;demo&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot; &#125;, &quot;tabBar&quot;: &#123; &quot;color&quot;: &quot;#dddddd&quot;, &quot;selectedColor&quot;: &quot;#3cc51f&quot;, &quot;backgroundColor&quot;: &quot;#ffffff&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot;, iconPath: &quot;&quot;, selectedIconPath: &quot;&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;日志&quot;, iconPath: &quot;&quot;, selectedIconPath: &quot;&quot; &#125;], &quot;position&quot;: &quot;bottom&quot; &#125;, &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000, &quot;connectSocket&quot;: 10000, &quot;uploadFile&quot;: 10000, &quot;downloadFile&quot;: 10000 &#125;, &quot;debug&quot;: true&#125; app.json 配置详细介绍以下包含属性皆为Object的json对象 pages (String)设置页面路径 window navigationBarBackgroundColor 导航栏背景颜色，如“#000000” navigationBarTextStyle 导航栏标题颜色，仅支持 black/white navigationBarTitleText 导航栏标题文字内容 backgroundColor 窗体的背景色 backgroundTextStyle 下拉背景字体、loading 图的样式，仅支持 dark/light enablePullDownRefresh 是否开启下拉刷新，详见页面相关事件处理函数。 tabBar 如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 color tab 上的文字默认颜色 selectedColor tab 上的文字选中时的颜色 backgroundColor tab 的背景色 borderStyle tabbar 上边框的颜色，仅支持 black/white list tab 的里列表，类型为数组，包含以下属性： pagePath 页面路径，必须在 pages 中先定义 text tab 上按钮文字 iconPath 图片路径，icon 大小限制为40KB selectedIconPath 选中时的图片路径，icon 大小限制为40KB position 可选值 bottom、top networkTimeout 可以设置各种网络请求的超时时间。类型都是Number request wx.request 的超时时间，单位毫秒 connectSocket wx.connectSocket 的超时时间，单位毫秒 uploadFile wx.uploadFile 的超时时间，单位毫秒 downloadFile wx.downloadFile 的超时时间，单位毫秒 debug 可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发 。 可以帮助开发者快速定位一些常见的问题。 page.json 页面配置每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。 页面的配置比 app.json 全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，如：1234567&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125;","categories":[{"name":"weChat","slug":"weChat","permalink":"http://gavinluo.cn/blog/categories/weChat/"}],"tags":[]},{"title":"","slug":"BEGIN","date":"2018-01-04T03:10:11.406Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/BEGIN/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/BEGIN/","excerpt":"","text":"开始于，2017-08-29 20:18:20","categories":[],"tags":[]},{"title":"NPM镜像源使用","slug":"NPM镜像源","date":"2018-01-04T03:10:11.405Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/NPM镜像源/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/NPM镜像源/","excerpt":"","text":"国内优秀 npm 镜像推荐及使用npm全称 Node Package Manager，是 nodejs 的模块依赖管理工具。由于 npm 的源在国外，所以国内访问很是不便。 国内优秀源淘宝 npm 镜像 搜索地址：http://npm.taobao.org/ registry地址：http://registry.npm/taobao.org/ cnpmjs 镜像 搜索地址：http://cnpmjs.org/ regitsry地址：http://r.cnpmjs.org/ 如何使用根据是用场景的不同，配置，npm 的 regitstry 地址。 以淘宝 npm 镜像安装 express 为例子 临时使用 1npm --registry https://registry.npm.taobao.org install express 持久使用 123456npm config set registry https://registry.npm.taobao.org# 验证是否成功npm config get registry# 或npm info express 通过 cnpm 使用 1234npm install -g cnpm --registry=https://registry.npm.taobao.org# 使用cnpm install express .","categories":[{"name":"NPM","slug":"NPM","permalink":"http://gavinluo.cn/blog/categories/NPM/"}],"tags":[]},{"title":"一台服务器配置多个tomcat","slug":"一台服务器配置多个tomcat","date":"2018-01-04T03:10:11.404Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/一台服务器配置多个tomcat/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/一台服务器配置多个tomcat/","excerpt":"","text":"环境系统环境：Linux（ubuntu14.04） 步骤：1、据说是不要设置CATALINA_HOME（网上说的，我也没有设置） 2、分别修改tomcat安装目录下的conf子目录中的server.xml文件： a、修改http访问端口（默认为8080端口），将8080修改为tomcat不在使用的端口号，&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;。此处所设置的端口号既是以后访问web时所用的端口号。例如：8181。（大概在server.xml的69行） b、修改其中一个tomcat的shutdown端口号（默认为8005），&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;，中的端口号修改为不在使用的端口号。例如：8095。（大概在server.xml的22行） c、修改端口号为8009的端口号，&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;，中的端口号为不在使用的端口号，例如：8099。（大概在server.xml的91行） 3、依次启动tomcat。 成功打开： http://localhost:8080/ http://localhost:8181/ 至此：tomcat在ubuntu上开启多个服务成功。","categories":[{"name":"server","slug":"server","permalink":"http://gavinluo.cn/blog/categories/server/"}],"tags":[]},{"title":"","slug":"科学上网，SS加速","date":"2018-01-04T03:10:11.402Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/科学上网，SS加速/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/科学上网，SS加速/","excerpt":"","text":"FinalSpeed给搬瓦工SS加速 Kcptun加速","categories":[],"tags":[]},{"title":"网站信息爬虫-基于NodeJs","slug":"网站信息爬虫-基于NodeJs","date":"2018-01-04T03:10:11.401Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/网站信息爬虫-基于NodeJs/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/网站信息爬虫-基于NodeJs/","excerpt":"","text":"步骤一：开发环境使用 下载并安装 NodeJs 前端编辑器webStorm 注意：安装 NodeJs 后可能 npm 包管理安装不成功（反正我就没有）, 需要自己手动安装 npm包管理器, 自行百度安装包管理器. 说明：npm（nodejs package manager），nodejs包管理器 步骤二：建立工程 创建根目录 npm init （初始化工程） 检查是否生成 package.json 文件 安装第三方包（程序需要使用的包） 说明：http模块、fs模块都是内置的包，不需要额外添加。 安装 cheerio 包, 和 request 包1234# cheerionpm install cheerio -save# requestnpm install request -save 项目文件目录 创建子文件夹 data （存放所抓取的文本类容） 创建子文件夹 image （存放抓取的图片资源） 创建 xyz_spider.js 文件 步骤三：编写代码 （talk is cheep, show me the code.） 示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;);var cheerio = require(&apos;cheerio&apos;);var i = 0;var max_article = 5;// 控制爬去文章数/** * 开始爬虫 * @param url 爬取数据的地址 */function startRequest(url) &#123; // 使用 http 模块向服务器发起一次 get 请求 var request_callee = arguments.callee; http.get(url, function (res) &#123; var html = &apos;&apos;;// 存储html内容 var titles = []; res.setEncoding(&apos;utf-8&apos;); // 监听data， 取数据块 res.on(&apos;data&apos;, function (chunk) &#123; html += chunk; &#125;); res.on(&apos;end&apos;, function () &#123; var $ = cheerio.load(html);// 采用cheerio模块解析html var time = $(&apos;.article-info a:first-child&apos;).next().text().trim(); var news_item = &#123; title: $(&apos;div.article-title a&apos;).text().trim(), Time: time, link: &quot;http://www.ss.pku.edu.cn&quot; + $(&quot;div.article-title a&quot;).attr(&apos;href&apos;), author: $(&apos;[title=供稿]&apos;).text().trim(), i: i = i+1 &#125;; console.log(news_item); var news_title = $(&apos;div.article-title a&apos;).text().trim();//文章标题 savedContent($, news_title);// 存储文章的内容及文章标题 saveImg($, news_title);// 存储文章的图书及图片标题 // 控制爬取文章数量 if(i &lt; max_article)&#123; var nextLink = &quot;http://www.ss.pku.edu.cn&quot; + $(&quot;li.next a&quot;).attr(&apos;href&apos;); nextLink = nextLink.split(&apos;-&apos;); nextLink = encodeURI(nextLink[0]); request_callee(nextLink); &#125; &#125;); &#125;).on(&apos;error&apos;, function (err) &#123; console.log(err); &#125;);&#125;/** * 保存文章的文本信息 * @param $ 请求回来的 html 数据解析对象 * @param news_title 新闻的标题 */function savedContent($, news_title) &#123; var content = &apos;&apos;; $(&apos;.article-content p&apos;).each(function (index, item) &#123; var x = $(this).text().trim(); if(!!x)&#123; content += &apos;\\t&apos; + x + &apos;\\n&apos;; &#125;else &#123; content += &apos;\\t&apos; + &apos;【图片文件】&apos; + &apos;\\n&apos;; &#125; &#125;); // 写入文件 fs.writeFile(&apos;./data/&apos; + news_title + &apos;.txt&apos;, content, &apos;utf-8&apos;, function (err) &#123; if(err)&#123; console.log(err); &#125; &#125;);&#125;/** * 保存文章图片 * @param $ 请求回来的 html 数据解析对象 * @param news_title 新闻标题 */function saveImg($, news_title) &#123; $(&apos;.article-content img&apos;).each(function (index, item) &#123; var img_title = $(this).parent().next().text().trim(); if(img_title.length &gt; 35 || img_title == &apos;&apos;)&#123; img_title = &apos;Null&apos;; &#125; var img_filename = img_title + &apos;.jpg&apos;; var img_src = &apos;http://www.ss.pku.edu.cn&apos; + $(this).attr(&apos;src&apos;); //获取图片的url // 发起请求 http.get(img_src, function (res) &#123; var imgData = &apos;&apos;; res.setEncoding(&quot;binary&quot;);//一定要设置response的编码为binary否则会下载下来的图片打不开 res.on(&apos;data&apos;, function (chunk) &#123; imgData += chunk; &#125;); res.on(&apos;end&apos;, function () &#123; fs.writeFile(&apos;./image/&apos; + news_title + &apos;--&apos; + img_filename, imgData, &apos;binary&apos;, function (err) &#123; if(err)&#123; console.log(err); &#125; &#125;); &#125;); &#125;).on(&apos;error&apos;, function (err) &#123; console.log(err); &#125;); &#125;);&#125;// 程序入口function main() &#123; var url = &quot;http://www.ss.pku.edu.cn/index.php/newscenter/news/2391&quot;; startRequest(url);&#125;// 启动程序main(); 总结 爬虫项目，关键在于选择器的设计。cheerio模块的选择器$，和jQuery选择器规则几乎是一样的。简单的 demo 实战了数据的采集，GitHub 上有一个开源的自制网页版的爬虫（传送门），很适合练手。以后来改进这个简单的爬虫，争取向产品化发展。","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/categories/NodeJs/"}],"tags":[]},{"title":"Windows下MongoDB安装","slug":"Windows下MongoDB安装","date":"2018-01-04T03:10:11.400Z","updated":"2017-07-05T13:15:00.000Z","comments":true,"path":"2018/01/04/Windows下MongoDB安装/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Windows下MongoDB安装/","excerpt":"","text":"下载官网下载：https://www.mongodb.com/download-center?jmp=nav#community 安装安装后需要创建，数据需要创建数据文件。 自行创建，或使用Windows资源管理工具创建 无需命令行 1234567891011c:\\&gt;cd c:\\c:\\&gt;mkdir datac:\\&gt;cd datac:\\data&gt;mkdir dbc:\\data&gt;cd dbc:\\data\\db&gt; 命令行运行 MongoDB 服务器为了从命令提示符下运行 MongoDB 服务器，你必须从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件。 1mongod --dbpath c:\\data\\db 执行成功后，会出显等待用户连接数据库的字样。 将MongodDB服务器，作为Windows服务运行1mongod.exe --bind_ip yourIPadress --logpath \"C:\\data\\dbConf\\mongodb.log\" --logappend --dbpath \"C:\\data\\db\" --port yourPortNumber --serviceName \"YourServiceName\" --serviceDisplayName \"YourServiceName\" --install 参数 描述 –bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP –logpath 定MongoDB日志文件，注意是指定文件不是目录 –logappend 使用追加的方式写日志 –dbpath 指定数据库路径 –port 指定服务端口号，默认端口27017 –serviceName 指定服务名称 –serviceDisplayName 指定服务名称，有多个mongodb服务时执行。 –install 指定作为一个Windows服务安装。 MongoDB后台管理 Shell如果你需要进入MongoDB后台管理，你需要先打开mongodb装目录的下的bin目录，然后执行mongo.exe文件，MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。 当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）： 1$ mongo","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://gavinluo.cn/blog/categories/MongoDB/"}],"tags":[]},{"title":"","slug":"了解Node-js","date":"2018-01-04T03:10:11.399Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/了解Node-js/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/了解Node-js/","excerpt":"","text":"前言Node.js网站：https://nodejs.org/中文论坛网站：https://cnodejs.org/ 学习NodeJs：https://nodeschool.io/ 正文","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/tags/NodeJs/"}]},{"title":"","slug":"VPS免费资源","date":"2018-01-04T03:10:11.398Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/VPS免费资源/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/VPS免费资源/","excerpt":"","text":"免费资源总汇https://github.com/ripienaar/free-for-dev#paas 服务器vps快云1元体验1个月服务器 http://host.zzidc.com/ad.html 景安1元买一年主机 http://host.zzidc.com/tongji/vhost.html 阿里云免费体验馆 https://free.aliyun.com/ 尊云免费体验 http://www.zun.com/tiyan.html 金山云免费体验 https://activity.ksyun.com/1703/index.html 腾讯云免费体验 https://www.qcloud.com/act/free 华为云免费体验套餐 http://activity.hwclouds.com/newuser_trial/index.html 亚马逊免费体验： https://amazonaws-china.com/cn/events/cloud/ 部署NodeJs免费 https://zeit.co/now","categories":[],"tags":[]},{"title":"基于jQuery鼠标经过事件的延时处理","slug":"jQuery-鼠标经过事件（hover）事件的延时处理","date":"2018-01-04T03:10:11.396Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/jQuery-鼠标经过事件（hover）事件的延时处理/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/jQuery-鼠标经过事件（hover）事件的延时处理/","excerpt":"","text":"jQuery - 鼠标经过事件（hover）事件的延时处理延时的方法，离不开window下的setTimeout方法，我使用的jQuery延时实现本质上是setTimeout。 123456789101112131415161718192021222324252627282930&lt;!-- 引入jquery --&gt;&lt;script src=&quot;../resource/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; (function ($) &#123; /** * 扩展 hover 事件，添加延时处理 * @param hoverEvent 鼠标经过执行的方法 * @param outEvent 鼠标移除执行的方法 * @return &#123;*&#125; */ $.fn.hoverDelay = function (hoverEvent, outEvent) &#123; var hoverTimer, outTimer; return $(this).each(function () &#123; $(this).hover(function () &#123; var t = this; clearTimeout(outTimer); hoverTimer = setTimeout(function () &#123; hoverEvent.call(t); &#125;, 500);// 鼠标经过的延时时间 &#125;, function () &#123; var t = this; clearTimeout(hoverTimer); outTimer = setTimeout(function () &#123; outEvent.call(t); &#125;, 0);// 鼠标移除的延时时间 &#125;); &#125;); &#125; &#125;)(jQuery);&lt;/script&gt; 使用方法： 12345678910&lt;script&gt; $(function () &#123; $(selector).hoverDelay(function () &#123; ... &#125;, function () &#123; ... &#125;); &#125;)&lt;/script&gt;","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://gavinluo.cn/blog/categories/jQuery/"}],"tags":[]},{"title":"","slug":"Font-End","date":"2018-01-04T03:10:11.395Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/Font-End/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Font-End/","excerpt":"","text":"云储存七牛：官网 HTML5 可视化设计工具Maqetta：官网 前端Router：fd-router.js：GitHub director.js：GitHub path.js：GitHub vipspa.js（移动端纯前端路由方案）：GitHub Loading插件jquery.blockUI.js：官网DOC、GitHub 文件上传jQuery.MultiFile.js：官网、GitHub 表单异步提交jQuery.form.js：官网、GitHub 时间格式解析与显示moment.js：官网、GitHub 组织架构图插件OrgChart（jq3.0+）：GitHub Ajax模拟数据返回Mock.js：官网、GitHub 原型设计工具Mockplus：官网 MockingBot：官网 NPM自由镜像源切换，管理工具nrm：GitHub、使用 ———–","categories":[],"tags":[]},{"title":"","slug":"小程序开发教程","date":"2018-01-04T03:10:11.394Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/小程序开发教程/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/小程序开发教程/","excerpt":"","text":"https://my.oschina.net/mrtudou/blog/784672","categories":[],"tags":[]},{"title":"FormData添加键值对时指定值得数据类型","slug":"FormData添加键值对时指定值的数据类型","date":"2018-01-04T03:10:11.393Z","updated":"2018-01-04T02:10:00.000Z","comments":true,"path":"2018/01/04/FormData添加键值对时指定值的数据类型/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/FormData添加键值对时指定值的数据类型/","excerpt":"","text":"前言使用 FormData() 文件异步上传时，经常出现一个需求在提交数据的时候，指定值的传输类型（Content-type）.例如： image 使用 HTTP Analyzer V7 抓包工具，抓到的请求中，两个数据项中都是出现了 Content-type 字段标识，数据类型。 image 为了实现单独数据设置content-type，我试了各种方法，包括自己组装 http 协议上传文件啊什么的，都是不行的。 正文仔细研究后发现是自己太蠢。在 MDN 上查询了一下 FormData 后发现， .append(name, value[, filename]) / .set(name, value[, filename]) 的方法中，value 值，都是可以传递 Blob 类型。 制定字符串的数据类型：123456var debug = &#123;hello: \"world\"&#125;;var blob = new Blob([JSON.stringify(debug, null, 2)], &#123;type : 'application/json'&#125;);# 添加到 formDatavar formData = new FormData();formData.append(\"attachment\", blob); 提交请求，在控制台发现，出现了想要的 Content-Type: appliction/json image 总结MDN 、脑子 是个好东西。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[]},{"title":"","slug":"CRTB","date":"2018-01-04T03:10:11.392Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/CRTB/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/CRTB/","excerpt":"","text":"CRTB Front-EndDOM库jQuery@2.1.4 jQuery@3.1.1 UI库boostrap@3.3.7 路由Routerdirector@1.2.8 注意：该框架，包含 client-router、server-router 详细使用，查看GitHub 文件上传jQuery.MultiFile.js@2.2.0","categories":[],"tags":[]},{"title":"前端自动化构建工具--GulpJs的使用介绍","slug":"前端自动化构建工具-GulpJs的使用介绍","date":"2018-01-04T03:10:11.391Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/前端自动化构建工具-GulpJs的使用介绍/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/前端自动化构建工具-GulpJs的使用介绍/","excerpt":"","text":"前言GulpJs是一个前端自动化构建工具，与GruntJs相比，GulpJs无需繁杂的 配置参数，API简单易用，学习成本低。并依赖NodeJs的读取操作接口执行速度更快。适合新手没有学习过自动化构建工具的开发者。 正文1、Gulp的安装确保已经安装Node、npm最新版，然后全局安装Gulp 1npm install -g gulp 全局安装完成后，还需要在相应的项目中单独安装一次，并安装为项目依赖，切换到项目目录下，执行命令 12cd gulp-test/npm install --save-dev gulp 2、开始使用Gulp2.1 建立 gulpfile.js 文件新建文件，存放到项目的根目录中，之后在文件中定义任务，以下为官方文档的简单默认任务实例： 12345var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 2.2 运行 Gulp 任务1234# 语法：# gulp &lt;task&gt; &lt;othertask&gt;# 默认执行为 gulp === gulp default$ gulp 3、Gulp的API介绍使用Gulp，仅需要4个API：==gulp.task()== , ==gulp.src()== , ==gulp.dest()== , ==gulp.watch()== ，容易掌握。官方API文档：http://www.gulpjs.com.cn/docs/api/ 3.1 gulp.src()Gulp中，使用的是Nodejs中的stream(流)，首先获取到需要的stream，然后可以通过stream的 ==pipe()== 方法把流导入到你想要的地方。 12// 语法gulp.src(globs[, options]); globs 参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。 options 为可选参数。通常情况下我们不需要用到。详细见官方文档 3.2 gulp.dest()该方法用来写文件，语法为： 1gulp.dest(path[,options]) path 为写入文件的路径 options 为一个可选的参数对象，通常我们不需要用到 3.3 gulp.task()方法用来定义任务，内部使用的是Orchestrator，其语法为： 1gulp.task(name[, deps], fn) name 任务名 deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数 fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 3.4 gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为： 12// 1gulp.watch(glob[, opts], tasks) glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。 opts 为一个可选的配置对象，通常不需要用到 tasks 为文件变化后要执行的任务，为一个数组 12// 2gulp.watch(glob[, opts, cb]) glob和opts参数与第一种用法相同 cb 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径 4、常用的Gulp插件HTML文件实时浏览、文件压缩、文件编译 4.1 自动加载插件使用：gulp-load-plugins 安装：npm install –save-dev gulp-load-plugins 4.2 重命名使用gulp-rename 安装：npm install –save-dev gulp-rename 4.3 js文件压缩使用gulp-uglify 安装：npm install –save-dev gulp-uglify 4.4 css文件压缩使用gulp-minify-css 安装：npm install –save-dev gulp-minify-css 4.5 html文件压缩使用gulp-minify-html 安装：npm install –save-dev gulp-minify-html 4.6 js代码检查使用gulp-jshint 安装：npm install –save-dev gulp-jshint 4.7 文件合并使用：gulp-concat 安装：npm install –save-dev gulp-concat 4.8 less和sass的编译less使用：gulp-less 安装：npm install –save-dev gulp-less sass使用：gulp-sass 安装：npm install –save-dev gulp-sass 4.9 图片压缩使用：gulp-imagemin 插件来压缩jpg、png、gif等图片 安装：npm install –save-dev gulp-imagemin 4.10 自动刷新使用：gulp-livereload 安装：npm install –save-dev gulp-livereload 使用方法：安装完成后，需要谷歌浏览器的配合，安装谷歌浏览器插件 LiveReload 参考Blog：http://www.cnblogs.com/2050/p/4198792.html","categories":[{"name":"Gulp","slug":"Gulp","permalink":"http://gavinluo.cn/blog/categories/Gulp/"}],"tags":[]},{"title":"","slug":"使用-Graphics-创建图片并保存本地","date":"2018-01-04T03:10:11.389Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/使用-Graphics-创建图片并保存本地/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/使用-Graphics-创建图片并保存本地/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package crtb.output.image;import java.awt.Color;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileOutputStream;import javax.imageio.ImageIO;public class ChartGraphics &#123; BufferedImage image; void createImage(String fileLoaction)&#123; try&#123; FileOutputStream fos = new FileOutputStream(fileLoaction); // begiin 1.7 开始，change to ImageIO// BufferedOutputStream bos = new BufferedOutputStream(fos);// JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(bos);// encoder.encode(image);// bos.close();// ImageIO.write(image, \"jpg\", fos); ImageIO.write(image, \"jpg\", new File(fileLoaction)); System.out.println(fileLoaction + \"--- build image done.\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void graphicsGeneration(String path, int h1, int h2, int h3, int h4, int h5) &#123; final int X = 10; int imageWidth = 600;//图片的宽度 int imageHeight = 300;//图片的高度 int columnWidth = 30;//柱的宽度 int columnHeight = 200;//柱的最大高度 // ChartGraphics chartGraphics = new ChartGraphics(); image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics graphics = image.getGraphics(); graphics.setColor(Color.white); graphics.fillRect(0, 0, imageWidth, imageHeight); graphics.setColor(Color.red); graphics.drawRect(X + 1 * columnWidth, columnHeight - h1, columnWidth, h1); graphics.drawRect(X + 2 * columnWidth, columnHeight - h2, columnWidth, h2); graphics.drawRect(X + 3 * columnWidth, columnHeight - h3, columnWidth, h3); graphics.drawRect(X + 4 * columnWidth, columnHeight - h4, columnWidth, h4); graphics.drawRect(X + 5 * columnWidth, columnHeight - h5, columnWidth, h5); createImage(path); &#125; public static void main(String[] args)&#123; int[] height = &#123;40, 50, 16, 22, 85&#125;; String path = \"E:/chart.jpg\"; ChartGraphics cg = new ChartGraphics(); try&#123; for(int i=0; i&lt;5; i++)&#123; cg.graphicsGeneration(path, height[0], height[1], height[2], height[3], height[4]); &#125; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Linux下配置sudo免密执行","slug":"Linux下配置sudo免密执行","date":"2018-01-04T03:10:11.388Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/Linux下配置sudo免密执行/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Linux下配置sudo免密执行/","excerpt":"","text":"在使用 gulp-ssh 上传文件的时候，需要用到，git拉取代码，但是，由于权限统一是，root的，所有每次拉取代码，需要使用 sudo 命令执行。 但是，gulp-ssh 不能够实现 sudo 输入密码，所以配置一个免密码登陆。 配置如下： 在远程机 /etc/sudoers 里面添加一行。添加这行需要有 sudoer 的权限。1username ALL=(ALL:ALL) NOPASSWD:ALL","categories":[{"name":"Linux","slug":"Linux","permalink":"http://gavinluo.cn/blog/categories/Linux/"}],"tags":[]},{"title":"","slug":"java绘制坐标系统库","date":"2018-01-04T03:10:11.387Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/java绘制坐标系统库/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/java绘制坐标系统库/","excerpt":"","text":"几款对比：传送门","categories":[],"tags":[]},{"title":"","slug":"javascript数组排序","date":"2018-01-04T03:10:11.386Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/javascript数组排序/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/javascript数组排序/","excerpt":"","text":"js使用Array.prototype.sort()对数组对象排序的方法： 我们先来简单的了解一下Array.prototype.sort()。sort方法接受一个参数——Function，function会提供两个参 数，分别是两个进行比较的元素，如果元素是String类型则通过Unicode code进行比较，如果是Number类型则比较值的大小。如果比较的函数中返回1则两个元素交换位置，0和-1不交换位置。先看一个例子： 123456var arr = [3, 5, 2, 1];// 从小到大排序arr.sort(function (a, b) &#123; return a &gt; b ? 1 : -1;&#125;);// 得到的结果：[1, 2, 3, 5] 如果是对一个数组对象进行排序，该怎么写呢？其实原理和上面一样，如： 1234567891011var arr = [ &#123; a : 2, b : 3.2&#125;, &#123; a : 3, b : 1.2&#125;, &#123; a : 4, b : 2.2&#125;, &#123; a : 6, b : 1.2&#125;, &#123; a : 5, b : 3.2&#125;]/// 从小到大按属性b排序arr.sort(function(x, y)&#123; return x.b &gt; y.b ? 1:-1;&#125;); 上面的例子中，最小的元素中有重复，如果需求是：先按b属性从小到大排序，如果最小中有重复则再按a属性排序，那应该怎么写呢？ 在排序的时候，先按b属性排序，如果x.b的大于y.b则将x移到y的右边，如果x.b等于y.b则再通过x.a和y.a进行比较，所以代码如下： 123456789arr.sort(function (x, y) &#123; if (x.b &gt; y.b) &#123; return 1; &#125; else if (x.b === y.b) &#123; return x.a &gt; y.a ? 1 : -1; &#125; else if (x.b &lt; y.b) &#123; return -1; &#125;&#125;)","categories":[],"tags":[]},{"title":"NodeJs链接MySQL数据库","slug":"NodeJs连接MySQL数据库","date":"2018-01-04T03:10:11.384Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/NodeJs连接MySQL数据库/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/NodeJs连接MySQL数据库/","excerpt":"","text":"连接Mysql数据库 安装连接mysql所需要的模块 1$ npm install -g mysql 直接上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 引入模块var mysql = require('mysql');const DATABASE = \"nodejs\";// 创建连接// var connection = mysql.createConnection(&#123;// host : 'localhost',// user : 'test',// password : '123456',// database : 'nodejs'// &#125;);var client = mysql.createConnection(&#123; host: 'localhost', user: \"test\", password: \"123456\"&#125;);// 建立连接client.connect();// 切换数据库client.query(\"use \" + DATABASE);// 添加数据function addDB(name, pwd, id) &#123; let queryString = `INSERT INTO \\`con-demo\\` (\\`id\\`, \\`name\\`, \\`password\\`) VALUES ('$&#123;id&#125;', '$&#123;name&#125;', '$&#123;pwd&#125;')`; client.query(queryString, function (err, res, fields) &#123; if (err) &#123; throw err; &#125; if (res) &#123; console.log(JSON.stringify(res)); &#125; client.end(); &#125;);&#125;// 数据库查找function queryDB() &#123; client.query(\"SELECT * FROM `con-demo`\", function (err, res, fields) &#123; if (err) &#123; throw err; &#125; if (res) &#123; for (let i = 0, tmp; i &lt; res.length; i++) &#123; tmp = res[i]; console.log('%d---%s---%s', tmp.id, tmp.name, tmp.password); &#125; &#125; client.end(); &#125;);&#125;// 修改function updataDB(id, column, newValue) &#123; let queryString = `UPDATE \\`con-demo\\` SET \\`$&#123;column&#125;\\`='$&#123;newValue&#125;' WHERE \\`id\\`='$&#123;id&#125;'`; client.query(queryString, function (err, res, fields) &#123; if (err) &#123; throw err; &#125; if (res) &#123; console.log(JSON.stringify(res)); &#125; client.end(); &#125;);&#125;// 删除function deleteDB(id) &#123; let queryString = `DELETE FROM \\`con-demo\\` WHERE \\`id\\`='$&#123;id&#125;'`; client.query(queryString, function (err, res, fields) &#123; if (err) &#123; throw err; &#125; if (res) &#123; console.log(JSON.stringify(res)); &#125; client.end(); &#125;);&#125;// 执行 // let id = 5;// addDB(\"1005\", \"123456\", id);// updataDB(id, \"name\", \"5555\");// deleteDB(id);// queryDB(); -用最简单的，增删查改，只为学习。","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/categories/NodeJs/"}],"tags":[]},{"title":"css3的 calc 属性","slug":"calc","date":"2018-01-04T03:10:11.383Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/calc/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/calc/","excerpt":"","text":"css3的 calc 属性https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc 概述CSS函数calc()可以用在任何一个需要、, 、、、或的地方。有了calc()，你就可以通过计算来决定一个CSS属性的值了。 你还可以在一个calc()内部嵌套另一个calc()，里面的calc()会被简单地视为加了括号。 语法12/* property: calc(express); */width: calc(100% - 80px); 值expression 一个数学表达式,该表达式的结果会作为最终的值。 表达式该表达式可以使用以下运算符任意组合（使用正常的运算符优先级顺序）。 + 加法 - 减法 * 乘法，乘数中至少要有一个是 类型的 \\/ 除法，被除数（/右面的数）必须是 类型的 例子使用calc()可以很容易的为一个对象设置一个左右两边相等的外边距.在这个例子中,使用CSS创建了一个横跨整个窗口的banner,该banner左右两边各有一个距离窗口边缘40像素的间距: 1234567891011121314.banner &#123; position:absolute; left: 5%; /* fallback for browsers without support for calc() */ left: calc(40px); width: 90%; /* fallback for browsers without support for calc() */ width: calc(100% - 80px); border: solid black 1px; box-shadow: 1px 2px; background-color: yellow; padding: 6px; text-align: center;&#125;&lt;div class=&quot;banner&quot;&gt;This is a banner!&lt;/div&gt; 自动调整表单域的大小以适应其容器的大小calc()的另外一个用例是用来确保一个表单域的大小适合当前的可用空间,而不会在保持合适的外边距的同时,因挤压超出其容器的边缘. CSS 12345678910111213input &#123; padding: 2px; display: block; width: 98%; /* fallback for browsers without support for calc() */ width: calc(100% - 1em); &#125;#formbox &#123; width: 130px; /* fallback for browsers without support for calc() */ width: calc(100% / 6); border: 1px solid black; padding: 4px;&#125; HTML 123456&lt;form&gt; &lt;div id=&quot;formbox&quot;&gt; &lt;label&gt;Type something:&lt;/label&gt; &lt;input type=&quot;text&quot;&gt; &lt;/div&gt;&lt;/form&gt; 使用CSS变量来嵌套calc()我们来看一下下面的代码： 123456.foo &#123; --widthA: 100px; --widthB: calc(var(--widthA) / 2); --widthC: calc(var(--widthB) / 2); width: var(--widthC);&#125; 在所有的变量都被展开后, widthC 的值就会变成 calc( calc( 100px / 2) / 2)，然后当它被赋值给 .foo 的 width属性 时，所有内部的这些calc()（无论嵌套的有多深）都将会直接被“拍”成一个括号（原文：be flattened to just parentheses），所以这个 width属性 的值就直接相当于 calc( ( 100px / 2) / 2)了，或者说就变成25px了。 简而言之：一个 calc() 里面的 calc() 就仅仅相当于是一个括号。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://gavinluo.cn/blog/categories/CSS/"}],"tags":[]},{"title":"","slug":"Socket-IO问题","date":"2018-01-04T03:10:11.382Z","updated":"2018-01-04T03:12:54.964Z","comments":true,"path":"2018/01/04/Socket-IO问题/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Socket-IO问题/","excerpt":"","text":"问题：io.sockets.manager.rooms和io.sockets.clients(‘particular room’)这两个函数使用时，报错误。 版本: “^1.7.2” 原因：版本更新问题 解决： 123io.sockets.manager.rooms 使用 io.sockets.adapter.rooms 代替io.sockets.clients(&apos;particular room&apos;) 换成了 io.sockets.adapter.rooms[&apos;private_room&apos;];","categories":[],"tags":[]},{"title":"SVG转base64","slug":"转base64","date":"2018-01-04T03:10:11.380Z","updated":"2017-12-05T13:15:00.000Z","comments":true,"path":"2018/01/04/转base64/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/转base64/","excerpt":"","text":"SVG转base64 123456789101112131415161718// Encode the SVG as base64var b64 = 'data:image/svg+xml;base64,'+window.btoa(div.innerHTML);var url = 'url(\"' + b64 + '\")';console.loundefined// Short script to encode our SVG in base64// This can be reversed using window.atob('base64')var svg = document.getElementsByTagName('svg')[0];// Convert the SVG node to HTML.var div = document.createElement('div');div.appendChild(svg.cloneNode(true));// Encode the SVG as base64var b64 = 'data:image/svg+xml;base64,'+window.btoa(div.innerHTML);var url = 'url(\"' + b64 + '\")';console.log(url);","categories":[{"name":"base64","slug":"base64","permalink":"http://gavinluo.cn/blog/categories/base64/"}],"tags":[]},{"title":"CSS的 box-shadow 属性","slug":"box-shadow","date":"2018-01-04T03:10:11.377Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/box-shadow/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/box-shadow/","excerpt":"","text":"语法1234567891011121314/* offset-x | offset-y | color */box-shadow: 60px -16px teal;/* offset-x | offset-y | blur-radius | color */box-shadow: 10px 5px 5px black;/* offset-x | offset-y | blur-radius | spread-radius | color */box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);/* inset | offset-x | offset-y | color */box-shadow: inset 5em 1em gold;/* Any number of shadows, separated by commas */box-shadow: 3px 3px red, -1em 0 0.4em olive; 取值inset 默认阴影在边框外。 使用inset后，阴影在边框内（即使是透明边框），背景之上内容之下。 这是头两个 &lt;length&gt; 值，用来设置阴影偏移量。&lt;offset-x&gt; 设置水平偏移量，如果是负值则阴影位于元素左边。 &lt;offset-y&gt; 设置垂直偏移量，如果是负值则阴影位于元素上面。可用单位请查看 &lt;length&gt; 。 如果两者都是0，那么阴影位于元素后面。这时如果设置了&lt;blur-radius&gt; 或&lt;spread-radius&gt; 则有模糊效果。 这是第三个 &lt;length&gt; 值。值越大，模糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。 这是第四个 &lt;length&gt; 值。取正值时，阴影扩大；取负值时，阴影.收缩。默认为0，此时阴影与元素同样大 。 相关事项查看 &lt;color&gt; 。如果没有指定，则由浏览器决定——通常是color的值，不过目前Safari取透明。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://gavinluo.cn/blog/categories/CSS/"}],"tags":[]},{"title":"","slug":"VUE基于Nuxtjs的服务器端渲染","date":"2018-01-04T03:10:11.376Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/VUE基于Nuxtjs的服务器端渲染/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/VUE基于Nuxtjs的服务器端渲染/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"无标题Markdown","date":"2018-01-04T03:10:11.375Z","updated":"2018-01-04T03:12:54.980Z","comments":true,"path":"2018/01/04/无标题Markdown/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/无标题Markdown/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"知乎优秀文章","date":"2018-01-04T03:10:11.374Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/知乎优秀文章/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/知乎优秀文章/","excerpt":"","text":"收藏JavaScript如何轻松学？https://zhuanlan.zhihu.com/p/26029422 一起脱去小程序的外套 - 微信小程序架构解析https://zhuanlan.zhihu.com/p/25105936","categories":[],"tags":[]},{"title":"CentOS的yum安装Nginx","slug":"CentOS的yum安装Nginx","date":"2018-01-04T03:10:11.373Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/CentOS的yum安装Nginx/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/CentOS的yum安装Nginx/","excerpt":"","text":"搬瓦工，CentOS系统，执行1$ yum install nginx 安装失败，没有找到这个包。 据说是因为 nginx服务不自带在yum库中 解决办法nginx官方方法：https://www.nginx.com/resources/wiki/start/topics/tutorials/install/ 需要将nginx服务添加到yum库中：12### 新建、或修改这个文件$ vim /etc/yum.repos.d/nginx.repo 将下列配置复制到 /etc/yum.repos.d/nginx.repo 下：123456[nginx]name=nginx repo### 可以修改，$releasever和$basearch，为查找到的值baseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 可以通过命令获取当前系统的：$releasever和$basearch123$ rpm -qa | grep centos-release# resultcentos-release-6-9.el6.12.3.i686 更改为：$releasever = 7 和 $basearch = i686","categories":[{"name":"Linux","slug":"Linux","permalink":"http://gavinluo.cn/blog/categories/Linux/"}],"tags":[]},{"title":"【转】Debounce和Throttle的原理及实现","slug":"Debounce-和-Throttle-的原理及实现","date":"2018-01-04T03:10:11.372Z","updated":"2018-01-03T02:10:05.000Z","comments":true,"path":"2018/01/04/Debounce-和-Throttle-的原理及实现/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Debounce-和-Throttle-的原理及实现/","excerpt":"","text":"原文：http://blog.csdn.net/redtopic/article/details/69396722","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[]},{"title":"Gulp.js自动化侯剑配置","slug":"Gulp-js自动化构建完整配置","date":"2018-01-04T03:10:11.370Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/Gulp-js自动化构建完整配置/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Gulp-js自动化构建完整配置/","excerpt":"","text":"注意：都要下载，chrome插件 LiveReload 或者，html文件末尾添加 websockt 的监听 1&lt;script src=\"//IP:35729/livereload.js?snipver=1\" async=\"\" defer=\"\"&gt;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * author: GavinLuo * site: https://gavinluo.cn/ * date: 2017/10/18 9:24 */var gulp = require('gulp'), connect = require('gulp-connect'), proxy = require('http-proxy-middleware');gulp.task('connect', function() &#123; connect.server(&#123; livereload: true, middleware: function (connect, opt) &#123; var middle = []; // 解析代理，中间健 middle.push(proxy('/webapi', &#123; target: 'http://IP:port/api', changeOrigin: true, pathRewrite: &#123; '^/webapi': '' &#125; &#125;)); return middle; &#125; &#125;);&#125;);// 监听文件变动gulp.task('watch', function () &#123; gulp.watch(['**/*.*']).on('change', function (event) &#123; console.log(event.path, event.type); gulp.src('').pipe(connect.reload()); &#125;);&#125;);// 打包文件夹为，ZIP文件gulp.task('zip', ['build'], function () &#123; let zip = require('gulp-zip'); gulp.src(`./$&#123;ROOT_DIR&#125;/**`) .pipe(zip('test.zip')) .pipe(gulp.dest('./')) .on('end', () =&gt; &#123; // 删除，dist，文件夹 setTimeout(function () &#123; let del = require('del'); del([ROOT_DIR]); &#125;, 2000); &#125;);&#125;);// 默认任务gulp.task('default', ['connect', 'watch']);","categories":[{"name":"Gulp","slug":"Gulp","permalink":"http://gavinluo.cn/blog/categories/Gulp/"}],"tags":[]},{"title":"Linux下安装nodejs","slug":"Linux下安装nodejs","date":"2018-01-04T03:10:11.369Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/Linux下安装nodejs/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Linux下安装nodejs/","excerpt":"","text":"在CentOS的机器上安装NodeJs的时候发现，yum install nodejs，根本没有这个东西（以前使用ubuntu都是直接，apt-get 安装的） 编译好的文件，设置全局下载NodeJs，linux版本：（http://nodejs.cn/download/）12345### 32位$ wget https://npm.taobao.org/mirrors/node/v8.4.0/node-v8.4.0-linux-x86.tar.xz### 64位$ wget https://npm.taobao.org/mirrors/node/v8.4.0/node-v8.4.0-linux-x64.tar.xz 解压：1$ tar -xvf node-v8.4.0-linux-x64.tar.xz 设置全局123$ ln -s /usr/local/src/node-v8.4.0-linux-x64.tar.xz/bin/node /usr/local/bin/node$ ln -s /usr/local/src/node-v8.4.0-linux-x64.tar.xz/bin/npm /usr/local/bin/npm 验证：12$ node -v$ npm -v yum 安装方法参考：https://nodejs.org/en/download/package-manager/#enterprise-linux-and-fedora 12345678### 标准版本$ curl --silent --location https://rpm.nodesource.com/setup_6.x | bash -### 最新版本$ curl --silent --location https://rpm.nodesource.com/setup_8.x | bash -### 安装sudo yum -y install nodejs","categories":[{"name":"Linux","slug":"Linux","permalink":"http://gavinluo.cn/blog/categories/Linux/"}],"tags":[]},{"title":"","slug":"前端UI合集","date":"2018-01-04T03:10:11.368Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/前端UI合集/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/前端UI合集/","excerpt":"","text":"ALL（JS） BetterScroll – 滑动组件，Scroll组件，滚动列表、选择器、轮播图、索引列表、开屏引导等组件 VUE MuseUI – 响应式 Element – 饿咯么的后台UI Vux – GitHub上stars很高，vue作者推荐，文档有点坑 cube-ui – 滴滴公司手机端UI组件 iView – PC端后台管理UI – –","categories":[],"tags":[]},{"title":"UCM","slug":"UCM","date":"2018-01-04T03:10:11.366Z","updated":"2018-01-04T03:12:54.949Z","comments":true,"path":"2018/01/04/UCM/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/UCM/","excerpt":"","text":"","categories":[],"tags":[{"name":"UCM","slug":"UCM","permalink":"http://gavinluo.cn/blog/tags/UCM/"}]},{"title":"","slug":"PhantomJS","date":"2018-01-04T03:10:11.365Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2018/01/04/PhantomJS/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/PhantomJS/","excerpt":"","text":"下载：http://phantomjs.org/download.html 注意：需要配置环境变量后才能使用 简单使用新建一个包含下面两行脚本的文本文件： 12console.log(&apos;Hello, world!&apos;);phantom.exit(); 将文件另存为 hello.js ，然后执行它： 1phantomjs hello.js 输出结果为： Hello, world!","categories":[],"tags":[]},{"title":"Nginx 做 proxy 不转发自定义 Header 问题","slug":"Nginx-做-proxy-不转发自定义-Header-问题解决","date":"2018-01-04T03:10:11.362Z","updated":"2017-04-10T03:20:00.000Z","comments":true,"path":"2018/01/04/Nginx-做-proxy-不转发自定义-Header-问题解决/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Nginx-做-proxy-不转发自定义-Header-问题解决/","excerpt":"","text":"使用nginx做负载均衡或http代理时，碰到http header不转发的问题。 配置里只有转发设置原始ip和host的 123456client_max_body_size 1000m;proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-real-ip $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;# proxy_set_header X-Forwarded-For $http_x_forwarded_for; 但是奇怪的发现我自定义的 header 被忽略掉了？？？？？？ 理论上转发header是基本的功能。 大佬们的研究： 打开 nginx 的 debug123# 配置调试daemon off;error_log logs/error.log debug; 查看errorlog12# 解析 header 时出现：2010/12/13 18:49:06 [info] 6248#1476: *1 client sent invalid header line: “wiz_api_version: 2″ while reading client request headers, client: 223.254.100.103, server: localhost, request: “POST /wizkm/a/upload HTTP/1.1″ 明显在自定义header处出现问题。 123456789101112131415# 找出个所以然：（自定义是否允许下划线）rc = ngx_http_parse_header_line(r, r-&gt;header_in, cscf-&gt;underscores_in_headers);if (r-&gt;invalid_header &amp;&amp; cscf-&gt;ignore_invalid_headers) # 在ngx_http_parse_header_line() 函数中if (ch == &apos;_&apos;) &#123; # 判断是否允许 下划线 if (allow_underscores) &#123; hash = ngx_hash(hash, ch); r-&gt;lowcase_header[i++] = ch; i &amp;= (NGX_HTTP_LC_HEADER_LEN – 1); &#125; else &#123; r-&gt;invalid_header = 1; &#125;&#125; 根据大佬们分析源码得出 Nginx是对header name的字符做了限制，默认 underscores_in_headers 为off，表示如果header name中包含下划线，则忽略掉。 恰好这里自定义的 header 中含有下划线。 ==处理办法：== 配置中http部分 增加 1underscores_in_headers on; 用减号 ‘-‘ 替代下划线符号 ‘_’，避免这种变态问题。nginx 默认忽略掉下划线可能有些原因。 来源： 我也忘了。。。-_-","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://gavinluo.cn/blog/categories/Nginx/"}],"tags":[]},{"title":"电商平台开发","slug":"电商平台开发","date":"2018-01-04T03:10:11.361Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2018/01/04/电商平台开发/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/电商平台开发/","excerpt":"","text":"本次DMEO，仅开发一个具有核心功能的电商平台；首先选进行准备工作，需求分析、技术选型、环境搭建等； 技术选型 软件过程： 敏捷开发 前后端分离： 完全分离，纯静态方式 模块化方案：CommonJS + Webpack 代理工具： Charles、Fiddler 框架选择： 用户端jQuery + css、管理系统React + Sass 版本控制： git 发布过程： 拉去代码 -&gt; 编译打包 -&gt; 发布到线上机器 环境搭建 git NodeJs、npm npm 的初始化、安装/卸载包、自动义命令 Webpack 12345# 需要首先安装一个全局的webpacknpm install webpack -g# 项目文件下npm isntall webpack --save-dev Webpack 配置文件处理 js 处理 — js-loader css 文件单文件打包引入 — css-loader、style-loader html 模板文件加载 — html-loader 静态资源 — url-loader、file-loader（有些版本不用的吧） Wrbpack-dev-server 开发神器 通用js工具的封装 网络请求：ajax请求、url配置 URL路径工具 模板渲染工具 – hogan 字段验证 &amp;&amp; 通用提示 统一跳转 。。。 界面布局没有设计狮，程序猿。 能爽死强迫症的对齐 你不知道的对称美 扁平化多, 减少代码量美观 保持一定的距离 配色是一门学问，灰色比较白搭（高端灰）","categories":[{"name":"demo","slug":"demo","permalink":"http://gavinluo.cn/blog/categories/demo/"}],"tags":[]},{"title":"上传本地代码到GitHub","slug":"上传本地代码到GitHub","date":"2018-01-04T03:10:11.360Z","updated":"2017-05-08T08:21:50.000Z","comments":true,"path":"2018/01/04/上传本地代码到GitHub/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/上传本地代码到GitHub/","excerpt":"","text":"提示：安装 Git 自行解决 1、建立Git仓库 1git init 2、添加项目文件到 仓库 1git add . 3、将 add 的文件commit 1git commit -m \"***\" 4、去github上创建自己的Repository 拿到仓库的 https 地址 例如：https://github.com/ShimingLuo/ShimingLuo.github.io.git 5、将本地仓库关联到 github 上 1234git remote add orgin https://github.com/ShimingLuo/ShimingLuo.github.io.git# 删除关联git remote remove orgin 6、上传之前，先 pull 一下 12345git pull orgin master# 提示：# 报错：fatal: refusing to merge unrelated historiesgit pull origin master --allow-unrelated-histories 7、上传到远程仓库 1git push -u orgin master 上传没有异常则，上传成功，可能会出现 Username 和 Password，只用输入GitHub的账号和密码就行。 #","categories":[{"name":"Git","slug":"Git","permalink":"http://gavinluo.cn/blog/categories/Git/"}],"tags":[]},{"title":"VUE初体验","slug":"冲突-VUE初体验","date":"2018-01-04T03:10:11.358Z","updated":"2017-07-05T13:15:00.000Z","comments":true,"path":"2018/01/04/冲突-VUE初体验/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/冲突-VUE初体验/","excerpt":"","text":"VUE简介VUE开发开发环境一、 安装NodeJs 悄悄的安装就好、npm + node 二、 安装VUE官方构建工具—-vue-cli 简介 vue-cli是官方的项目构建工具，一个简单的构建工具，通过几个默认的步骤帮助你快速的构建Vue.js项目。 安装 12# 国内速度的原因，请更换npm镜像npm install -g vue-cli 选择模板 官方项目模板 vuejs-templates 1$ vue init &lt;template-name&gt; &lt;project-name&gt; 也可以是用以下命令来查看官方模板列表： 1$ vue list 目前官方包含可用的： browserify –– 全功能的Browserify + vueify，包括热加载，静态检测，单元测试 browserify-simple –– 一个简易的Browserify + vueify，以便于快速开始。 webpack –– 全功能的Webpack + vueify，包括热加载，静态检测，单元测试 webpack-simple –– 一个简易的Webpack + vueify，以便于快速开始。 simple — 单个HTML文件中最简单的Vue设置 pwa — Vue CLI基于WebPACK模板 第一个项目 初始化项目 1234# 初始化vue init webpack vue-demo# 安装依赖npm install 预览 1$ npm run dev ss","categories":[{"name":"vue","slug":"vue","permalink":"http://gavinluo.cn/blog/categories/vue/"}],"tags":[]},{"title":"RestFul API接口生成API接口文档","slug":"RestFul-API接口生成API接口文档","date":"2018-01-04T03:10:11.356Z","updated":"2017-12-31T08:30:00.000Z","comments":true,"path":"2018/01/04/RestFul-API接口生成API接口文档/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/RestFul-API接口生成API接口文档/","excerpt":"","text":"前言在后端开发api接口后，需要前后端联调需要一个接口说明文档。我使用Node开发API完成后，需要书写一个自己和别人都能看的文档，于是借助apidoc工具 传送门： 官网 安装 apidoc基于 NodeJs下的，需要安装 Node、Npm 1234$ npm install -g apidoc# 目前 apidoc 已经支持 Grunt 自动化构建工具$ npm install grunt-apidoc --save-dev 使用 工具 在 package.json 文件中添加1234\"apidoc\": &#123; \"title\": \"NodeJs博客API\", \"url\" : \"http://localhost:8080/api\"&#125; 在接口位置添加注释，模板：1234567891011/** * @api &#123;method&#125; path [title] * @apiDescription text * @apiName name * @apiGroup name * * @apiParam &#123;string&#125; name 用户名 * @apiParam &#123;string&#125; password 密码 * * @apiVersion 1.0.0 */ 注释详细配置，直接去官网。传送门 12# run$ apidoc -i api/ -o apidoc/ [-t mytemplate/] 成功后会在 apidoc/ 目录下生成文档，html。 Grunt 方式 在 Gruntfile.js 添加1grunt.loadNpmTasks('grunt-apidoc'); 配置 grunt task123456apidoc: &#123; myapp: &#123; src: \"app/\", dest: \"apidoc/\" &#125;&#125; 1234567891011121314// 在sails中2和3可以直接添加一个taskmodule.exports = function(grunt) &#123; grunt.config.set('clean', &#123; apidoc: &#123; myapp: &#123; src: \"app/\", dest: \"apidoc/\" &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-apidoc');&#125;; 查看直接访问，生成目录中的，index.html，就可以访问","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/categories/NodeJs/"}],"tags":[]},{"title":"Node版Hello World","slug":"NodeJs-Hello-World","date":"2018-01-04T03:10:11.355Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2018/01/04/NodeJs-Hello-World/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/NodeJs-Hello-World/","excerpt":"","text":"正文 NodeJs官网（https://nodejs.org/en/，http://nodejs.cn/） 12345678var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; // request 请求，response 响应 response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); // 发送的数据 response.end(&apos;Hello World！&apos;);&#125;).listen(8124, &quot;127.0.0.1&quot;);console.log(&apos;Server running at http://127.0.0.1:8124&apos;); 总结NodeJs使用时需要是用，require(“modul-name”)，添加需要是用的模块;","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/tags/NodeJs/"}]},{"title":"NPM的使用","slug":"NPM使用","date":"2018-01-04T03:10:11.354Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2018/01/04/NPM使用/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/NPM使用/","excerpt":"","text":"npm更换淘宝镜像源1、通过 config 命令 123$ npm config set registry https://registry.npm.taobao.org# 如果上面的配置正确这个命令会有字符串 response$ npm info underscore 2、命令行指定 1$ npm --registry https://registry.npm.taobao.org info underscore 3、编辑 ~/.npmrc 加入下面配置 1registry = https://registry.npm.taobao.org","categories":[{"name":"NPM","slug":"NPM","permalink":"http://gavinluo.cn/blog/categories/NPM/"}],"tags":[]},{"title":"NodeJs学习的5个经典项目","slug":"Node-JS学习的5个经典项目","date":"2018-01-04T03:10:11.353Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2018/01/04/Node-JS学习的5个经典项目/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/Node-JS学习的5个经典项目/","excerpt":"","text":"基础篇项目一：网站信息爬虫 实现一个网站信息爬虫，学习使用Nodejs中的HTTP模块及信息提取方法。 项目二：在线笔记 课程实现一个简易的在线笔记网站，涉及到 NodeJS基础知识及Express框架。 项目三：漂流瓶 实现一个简单的漂流瓶应用，主要学习NodeJS整合Redis的使用。 进阶篇项目四：在线聊天室 实现在线聊天室应用，涉及NodeJS、socket.io、Angular.js相关技术。 项目五：个人博客 实现多人博客系统，其中会学习使用 NodeJS基础知识、mongoDB数据库和Express框架开发。","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/categories/NodeJs/"}],"tags":[]},{"title":"审核简历的一点点想法","slug":"审核简历的一点点想法","date":"2018-01-04T03:10:11.352Z","updated":"2017-04-12T12:41:00.000Z","comments":true,"path":"2018/01/04/审核简历的一点点想法/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/审核简历的一点点想法/","excerpt":"","text":"先谈我自己工作这么久了，还是对简历不是很懂，对面试的经验更是小白中的小白（ps：面试后直接开始工作，没有过与不过之说。而且当时简历都没有带！）。 以前听各种老师说简历感觉很是高端，写简历是一门专项技能；当自己找工作的时候总是觉得简历写得太菜，HR可能一般还没加载出来就关掉了。连面试的机会都没有。没有什么过多的样式，没有过多颜色，最多就只是黑白的几个框框。贴了一个头像可能就是全篇的亮点。 -O- 我自己的简历下次贴，我电脑里没有。 别人的简历案例（我的评价全是以技术简历方面出发）今天老大叫我审核别个实习生的简历，筛选一些好得出来，让我假吧意思当了一把HR。 这个机会难得啊，不仅可以看别人的简历是咋个写的，什么样的简历才能吸引我的目光、或是让我记忆深刻。其实最重要的是可以看看，现在这些是人都懂些啥子样的技术，和我不知道的知识。 先看一个专科生的简历（这是唯一一个没有被我刷掉的专科学历的人）： 示例简历 看到这个简历，是不是很LOW，对没错我当时也是这样觉得。资格的黑白配，和密密麻麻的文字，行间距宅得没法。说白了就是不想看，想关。 但是，可能由于我是第一次当“HR”，还是扫了一眼。 然后我看到一个特别与其他简历的地方，他在最后放了一个，个人链接。我这个最喜欢看各种人设计与喜欢的界面，我本能的点了进去，发现，他自己做得项目真的很棒，至少有几个我想做的DEMO，他做了出来，并且他的blog上有些自己的学习历程。 所有，我留下他的简历，刷掉了各种什么本科的啊，什么硕士的啊（ps：我不想刷的，毕竟学历那么高，但是真的项目经验都不这个专科生）。 这简历是众多中的一个（很不想刷掉的，因为人长得不错，但是老大命令留下来的数量有限）： image 这个简历明显是凑出来的项目经验，找完了没有看到自己的项目托管地址，和自己的心得感悟托放地址。没有一个值得看得地方。（和我当初的简历差不多，技术性不强） 这是一般的简历（优势就是一眼把要看到看完） image 分层级，HR只用关注自己想看的一层。而且提供博客地址（对我来说得好处就是可以看这个人做了些啥子，有啥子感悟之类的）。 说一哈看了将近50封简历，发现，简历花哨真的很容易审美疲劳，简洁、提供作品展示、自己成长历程，这些才是真的核心。（当然这还是要看你是哪个行业，至少技术流的行业重的作品和能力） 。 我太吉儿傻了，有啥子不对的地方直接来打我就好，别BB那么多！ 还有就是没有开通评论功能，直接请打电话骂我。","categories":[{"name":"面试","slug":"面试","permalink":"http://gavinluo.cn/blog/categories/面试/"}],"tags":[]},{"title":"PHP初体验","slug":"PHP初体验","date":"2018-01-04T03:10:11.351Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2018/01/04/PHP初体验/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/PHP初体验/","excerpt":"","text":"PHP安装我是初学者安装的是PHP服务器组件（集成了服务器组件，PHP、Apache、Mysql） Windwos系统下，WampServer，一路点击，Next。 还有一个是：（支持 Mac OS 和 Windows）XAMPP 第一个PHP站点，配置启动 wampserver 后直接开始，直接浏览器输入，localhsost，进入配置站点。 开始PHP基础12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php // 定义代码在 'MyProject' 命名空间中 ，必须在第一位 namespace MyProject; // 引入命名空间 // use myproject as prj; // $obj = new namespace\\Another; // 实例化 foo\\Another 对象 ?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;DEMO01.&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php // 打印 echo \"Hello World!&lt;br/&gt;\"; // 数据 $a = 5; $arr = [1, 2, 3, 4, 5]; echo $arr[0]; function test()&#123; echo '函数名为：' . __FUNCTION__ ; $b = 6; echo $GLOBALS['a']; &#125; test(); // 连接字符串 echo \"aaa\".\"bbb\"; // 魔术变量 echo '这是第 \" ' . __LINE__ . ' \" 行 &lt;br&gt;'; echo '该文件位于 \" ' . __FILE__ . ' \" &lt;br&gt;'; echo '该文件位于 \" ' . __DIR__ . ' \" &lt;br&gt;'; // 类声明 class test01 &#123; function _print() &#123; echo '类名为：' . __CLASS__ . \"&lt;br&gt;\"; echo '函数名为：' . __FUNCTION__ ; &#125; &#125; $t = new test01(); // 操作符 -&gt; $t -&gt; _print();?&gt;&lt;/body&gt;&lt;/html&gt; 还有很多，例如一些，后端服务器的高级应用，文件的下载上传啊。。传送门 操作数据库12345678910111213141516171819202122232425&lt;?php$servername = \"localhost\";$username = \"php\";$password = \"13213\"; // 创建连接$conn = new mysqli($servername, $username, $password); // 检测连接if ($conn-&gt;connect_error) &#123; die(\"连接失败: \" . $conn-&gt;connect_error);&#125;echo \"连接成功&lt;br&gt;\";$sql = \"SELECT * FROM php.user;\";$result = $conn-&gt;query($sql);while($row = $result-&gt;fetch_assoc())&#123; echo \"id: \" . $row['id'] . \"&lt;br&gt;userid: \" . $row['userid'] . \"&lt;br&gt;userpassword: \" . $row['userpassword'];&#125;$conn-&gt;close();// 实例关闭数据库// mysqli_close($conn);?&gt; 厉害咯","categories":[{"name":"PHP","slug":"PHP","permalink":"http://gavinluo.cn/blog/categories/PHP/"}],"tags":[]},{"title":"","slug":"test","date":"2018-01-04T03:10:11.350Z","updated":"2018-01-04T03:12:54.918Z","comments":true,"path":"2018/01/04/test/","link":"","permalink":"http://gavinluo.cn/blog/2018/01/04/test/","excerpt":"","text":"header 1 ss row 1 col 1 row 1 col 2 row 2 col 1 row 2 col 2 sdfsdsdfsdfsdfsdsfdsdf","categories":[],"tags":[]},{"title":"前端请求拦截并模拟返回随机数据--Mock.js","slug":"前端请求拦截并模拟返回随机数据-Mock-js","date":"2017-11-06T09:51:42.000Z","updated":"2017-11-06T09:51:42.000Z","comments":true,"path":"2017/11/06/前端请求拦截并模拟返回随机数据-Mock-js/","link":"","permalink":"http://gavinluo.cn/blog/2017/11/06/前端请求拦截并模拟返回随机数据-Mock-js/","excerpt":"","text":"最近在实现一个电商前端页面，但没有现成的后端接口，数据显示总感觉没有调试对，在git上找到了这个，Mock.js。 还有一个使用mock返回模拟数据的，项目设计的假API。 RAP","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/tags/javascript/"},{"name":"工具","slug":"工具","permalink":"http://gavinluo.cn/blog/tags/工具/"}]},{"title":"Javascript面试题合集","slug":"JS前端面试题","date":"2017-11-06T09:51:42.000Z","updated":"2017-11-06T09:51:42.000Z","comments":true,"path":"2017/11/06/JS前端面试题/","link":"","permalink":"http://gavinluo.cn/blog/2017/11/06/JS前端面试题/","excerpt":"","text":"12345678910111213var name = \"jay\";var person = &#123; name: \"kang\", pro: &#123; name: \"Michael\", getName: function() &#123; return this.name; &#125; &#125;&#125;;console.log(person.pro.getName());// Michaelvar pepole = person.pro.getName;console.log(pepole());// jay 123456789101112131415setTimeout(function ()&#123; console.log('timeout1');&#125;)new Promise(function (resolve)&#123; console.log('promise1'); for(var i = 0; i&lt;1000;i++)&#123; i==99&amp;&amp; resolve(); &#125; console.log('promise2');&#125;).then(function()&#123; console.log('then1');&#125;)console.log('global1');","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"http://gavinluo.cn/blog/tags/面试/"}]},{"title":"【转】分享几个好玩的js脚本","slug":"分享几个好玩-实用的javascript书签脚本","date":"2017-04-06T09:51:42.000Z","updated":"2017-04-06T09:51:42.000Z","comments":true,"path":"2017/04/06/分享几个好玩-实用的javascript书签脚本/","link":"","permalink":"http://gavinluo.cn/blog/2017/04/06/分享几个好玩-实用的javascript书签脚本/","excerpt":"","text":"如何使用 以谷歌浏览器为例，在浏览器书签栏点击右键 &gt; 选择添加网页/添加标签 &gt; 在网址处添加javascript代码。用时点击标签即可。 原文地址：http://www.zhangdanteng.com/ 让网页嗨起来1javascript:void(function()&#123;var d = document,a = &apos;setAttribute&apos;,s = d.createElement(&apos;script&apos;);s[a](&apos;tyle&apos;,&apos;text/javascript&apos;);s[a](&apos;src&apos;,&apos;http://www.zhangdanteng.com/wp-content/themes/Akina-master/bauble/happy.js&apos;);d.head.appendChild(s);&#125;)(); 用松鼠下载视频1javascript:location.href = &apos;http://www.flvcd.com/parse.php?flag=&amp;format=&amp;kw=&apos; + location.href; 夜间访问1javascript:var nuStyle=document.createElement(&apos;link&apos;);nuStyle.rel=&apos;stylesheet&apos;;nuStyle.rev=&apos;stylesheet&apos;;nuStyle.href=&apos;data:text/css,*&#123;background:#222222 !important;color:#ffffff !important;&#125; :link&#123;color:#ffffff !important;&#125; :visited&#123;color:#888888 !important;&#125;&apos;;void(document.documentElement.childNodes[0].appendChild(nuStyle)); 百度站内搜索1javascript:(function()&#123; p=prompt(&apos;%E5%9C%A8 &apos;+document.location.href.split(&apos;/&apos;)[2]+&apos; %E4%B8%AD%E6%90%9C%E7%B4%A2&apos;,&apos;&apos;); if(p)&#123; document.open(&apos;http://www.baidu.com/s?wd=site:&apos;+document.location.href.split(&apos;/&apos;)[2]+&apos; &apos;+p,&apos;&apos;,&apos;&apos;)&#125; &#125;)(); 左右分屏1javascript:document.write(&apos;%3CHTML%3E%3CHEAD%3E%3C/HEAD%3E%3CFRAMESET%20COLS=\\&apos;50%25,*\\&apos;%3E%3CFRAME%20SRC=&apos;%20+%20location.href%20+%20&apos;%3E%3CFRAME%20SRC=&apos;%20+%20location.href%20+%20&apos;%3E%3C/FRAMESET%3E%3C/HTML%3E&apos;) 上下分屏1javascript:document.write(&apos;&apos;) 简繁转换1javascript:(function()&#123;var%20s=document.getElementById(&quot;tongwenlet_tw&quot;);if(s!=null)&#123;document.body.removeChild(s);&#125;var%20s=document.createElement(&quot;script&quot;);s.language=&quot;javascript&quot;;s.type=&quot;text/javascript&quot;;s.src=&quot;http://tongwen.openfoundry.org/NewTongWen/tools/bookmarklet_tw.js&quot;;s.id=&quot;tongwenlet_tw&quot;;document.body.appendChild(s);%20&#125;)(); 有道翻译1javascript: void((function() &#123;var element = document.createElement(&apos;script&apos;);element.id = &apos;outfox_seed_js&apos;;element.charset = &apos;utf-8&apos;,element.setAttribute(&apos;src&apos;, &apos;http://fanyi.youdao.com/web2/seed.js?&apos; + Date.parse(new Date()));document.body.appendChild(element);&#125;)()) 链接可点击1javascript:-1,-1,(function(v)%7Bwith(document.body)%7BinnerHTML=innerHTML.replace(/(%5Cw+)(:%5C/%5C/%5B%5Cw-.!~*&apos;;%5C/?:@&amp;=+%24,%#%5D+%29%28?=%5B%5E%3E%5D*%28%3C%7C%24%29%29/g,function%28s,t,u%29%7Breturn%28s.link%28v%5Bt%5D?v%5Bt%5D+u:s%29%29%7D%29%7D%7D%29%28%7B%27ttp%27:%27http%27,%27tp%27:%27http%27,%27ttps%27:%27https%27,%27tps%27:%27https%27%7D%29 根据ID访问百度云1javascript:void ((function()&#123;var id=prompt(&quot;请输入百度云网盘ID&quot;);if(id)&#123;window.open(&quot;http://pan.baidu.com/s/&quot;+id)&#125;&#125;)());","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/tags/javascript/"},{"name":"书签脚本","slug":"书签脚本","permalink":"http://gavinluo.cn/blog/tags/书签脚本/"}]},{"title":"上传表单","slug":"uploadAttachment-boundary-string","date":"2017-04-06T09:51:42.000Z","updated":"2017-04-06T09:51:42.000Z","comments":true,"path":"2017/04/06/uploadAttachment-boundary-string/","link":"","permalink":"http://gavinluo.cn/blog/2017/04/06/uploadAttachment-boundary-string/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081function uploadAttachment(objectData, onSuccess, onError) &#123; // Define a boundary var boundary = 'crtb_boundary_string_' + Date.now().toString(); var attachmentContentType = !(objectData.ContentType) ? objectData.ContentType : 'application/octet-stream'; // Serialize the object, excluding the body, which will be placed in the second partition of the multipart/form-data request // var serializedObject = JSON.stringify(objectData, function (key, value) &#123; // return key !== 'Body' ? value : undefined; // &#125;); var jsonD = objectData.JsonData; var serializedObject = JSON.stringify(jsonD.data); var requestBodyBeginning = '--' + boundary + '\\r\\n' + 'Content-Disposition: form-data; name=\"' + jsonD.name + '\";' + '\\r\\n' + 'Content-Type: application/json' + '\\r\\n\\r\\n' + serializedObject + '\\r\\n\\r\\n' + '--' + boundary + '\\r\\n' + 'Content-Type: ' + attachmentContentType + '\\r\\n' + 'Content-Disposition: form-data; name=\"attachment\"; filename=\"icon\"' + '\\r\\n\\r\\n'; var requestBodyEnd = '\\r\\n\\r\\n' + '--' + boundary + '--'; // The atob function will decode a base64-encoded string into a new string with a character for each byte of the binary data. var byteCharacters = window.atob(objectData.Body); // Each character's code point (charCode) will be the value of the byte. // We can create an array of byte values by applying .charCodeAt for each character in the string. var byteNumbers = new Array(byteCharacters.length); for (var i = 0; i &lt; byteCharacters.length; i++) &#123; byteNumbers[i] = byteCharacters.charCodeAt(i); &#125; // Convert into a real typed byte array. (Represents an array of 8-bit unsigned integers) var byteArray = new Uint8Array(byteNumbers); var totalRequestSize = requestBodyBeginning.length + byteArray.byteLength + requestBodyEnd.length; var uint8array = new Uint8Array(totalRequestSize); var i; // Append the beginning of the request for (i = 0; i &lt; requestBodyBeginning.length; i++) &#123; uint8array[i] = requestBodyBeginning.charCodeAt(i) &amp; 0xff; &#125; // Append the binary attachment for (var j = 0; j &lt; byteArray.byteLength; i++, j++) &#123; uint8array[i] = byteArray[j]; &#125; // Append the end of the request for (var j = 0; j &lt; requestBodyEnd.length; i++, j++) &#123; uint8array[i] = requestBodyEnd.charCodeAt(j) &amp; 0xff; &#125; return $.ajax(&#123; type: \"POST\", url: Server.getServerRoot() + \"/file\", contentType: 'multipart/form-data' + \"; boundary=\\\"\" + boundary + \"\\\"\", cache: false, processData: false, data: uint8array.buffer, success: onSuccess, error: onError, beforeSend: function (xhr) &#123; // Setup OAuth headers... xhr.setRequestHeader(\"REMOTE_TOKEN\", \"qwerty123456!@#$%6\"); &#125; &#125;);&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/tags/javascript/"}]},{"title":"Javascript模块化编程：AMD应用","slug":"Javascript模块化编程：AMD应用","date":"2017-04-06T09:51:42.000Z","updated":"2017-04-06T09:51:42.000Z","comments":true,"path":"2017/04/06/Javascript模块化编程：AMD应用/","link":"","permalink":"http://gavinluo.cn/blog/2017/04/06/Javascript模块化编程：AMD应用/","excerpt":"","text":"JS模块化编程背景Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 但是，Javascript不是一种模块化编程语言，它不支持”类”（class），更遑论”模块”（module）了。（ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用。） 模块就是实现特定功能的一组方法。 123456function f01()&#123; // code...&#125;function f02()&#123; // code...&#125; 上面的函数f01()和f02()，组成一个模块。使用的时候，直接调用就行了。 缺点明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 独立性模块 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 123var module1 = (function($, YAHOO)&#123; // code...&#125;)(jQuery, YAHOO); 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。 模块规范为什么模块重要？ 有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。 但是，这样做有一个前提，那就是大家必须以同样的方式编写模块。 Javascript模块规范有两种：CommonJS 和 AMD。主要介绍AMD，但是先从CommonJS讲起。 CommonJS（服务器端）2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。 node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。 12345// 加载var math = require('math');// 调用模块提供方法math.add(2, 3); // 5 有了服务器端模块以后，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。 但是，由于该规范采用的是“同步加载”，在浏览器环境中存在网络延迟问题，可能等待较长时间，出现“假死”状态；使得 CommonJS 规范不适用于浏览器环境。 因此，浏览器端的模块，不能采用“同步加载”（synchronous），只能采用“异步加载”（asynchronous）。 AMD规范AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样： 123require([\"math\"], function(math)&#123; math.add(2, 3);&#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。 模块应用（AMD应用）require.js流行的AMD库 require.js 1. 为什么使用 最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。 123456&lt;script src=\"1.js\"&gt;&lt;/script&gt;&lt;script src=\"2.js\"&gt;&lt;/script&gt;&lt;script src=\"3.js\"&gt;&lt;/script&gt;&lt;script src=\"4.js\"&gt;&lt;/script&gt;&lt;script src=\"5.js\"&gt;&lt;/script&gt;&lt;script src=\"6.js\"&gt;&lt;/script&gt; 这样的写法很大的缺点：首先，在加载时，浏览器会停止网页渲染；其次，由于文件之间依赖关系，必须严格保证加载顺序。 require.js的诞生，就是为了解决这两个问题： （1）实现js文件的异步加载，避免网页失去响应； （2）管理模块之间的依赖性，便于代码的编写和维护。 2. require.js的加载 12345678&lt;!-- 同步引用 --&gt;&lt;script src=\"js/require.js\"&gt;&lt;/script&gt;&lt;!-- 异步引用 --&gt;&lt;script src=\"js/require.js\" defer async=\"true\" &gt;&lt;/script&gt;&lt;!-- 指定，入口文件引用 --&gt;&lt;script src=\"js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt; math.js 12345678define(function () &#123; var add = function (x, y) &#123; return x + y; &#125;; return &#123; add: add &#125;;&#125;); main.js 12345678910111213141516171819202122232425262728293031323334353637383940require.config(&#123; baseUrl: \"./lib\", paths: &#123; \"jquery\": \"jquery/jquery-2.1.4\", // 支持，配置多路径 // \"jquery\": [\"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\", \"jquery/jquery-2.1.4\"], \"jquery.blockUI\": \"jquery.blockUI-2.70\", \"director\": \"director-1.2.8/build/director\", \"math\": \"../assets/js/math\" &#125;, // 加载非规范模块 shim: &#123; \"jquery.blockUI\": &#123; deps: [\"jquery\"], exports: \"jQuery.fn.blockUI\" // 可删除 &#125;, // \"jquery.blockUI\": [\"jquery\"], // 简写不需要输出变量的库（插件） \"director\": &#123; //deps: [], // 可删除 exports: \"Router\" &#125; &#125;&#125;);require([\"jquery\", \"jquery.blockUI\"], function ($) &#123; $.blockUI(); setTimeout(function () &#123; $.unblockUI(); &#125;, 1000);&#125;);require([\"director\"], function (Router) &#123; var routes = &#123; '/home': function () &#123; console.log(\"home\"); &#125; &#125;; var router = Router(routes); router.init();&#125;); require.js还提供一系列 插件，实现一些特定的功能。自行查看 seaJs 待 总结等 ES6 完全普及时，自带了一个 module 加载的方法。当然现在也可以使用 Babel 将 ES6 代码转为 ES5 ，也是可以是直接使用的，但是需要 Node 环境来支持转化。 学习来源：http://www.ruanyifeng.com/blog/2012/11/require_js.html","categories":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://gavinluo.cn/blog/tags/javascript/"},{"name":"AMD","slug":"AMD","permalink":"http://gavinluo.cn/blog/tags/AMD/"},{"name":"require","slug":"require","permalink":"http://gavinluo.cn/blog/tags/require/"}]},{"title":"hexo搭建oschina、GitHub免费博客","slug":"hexo搭建oschina、GitHub免费博客","date":"2017-04-05T09:18:18.000Z","updated":"2017-04-05T09:18:18.000Z","comments":true,"path":"2017/04/05/hexo搭建oschina、GitHub免费博客/","link":"","permalink":"http://gavinluo.cn/blog/2017/04/05/hexo搭建oschina、GitHub免费博客/","excerpt":"","text":"前言 学习地址 https://my.oschina.net/z707z/blog/824830 Hexo官网 官方地址、中文文档 开始搭建环境1. NodeJs 安装 完成后，更换NPM的镜像源12# 敬华夏最伟大的墙$ npm config set registry http://registry.cnpmjs.org #切换npm为淘宝镜像 2. Hexo安装 1$ npm install -g hexo-cli 本地初始化运行Hexo执行以下命令后，Hexo会在项目下创建所需的文件123456# 初始化$ hexo init &lt;folder&gt;# $ cd &lt;folder&gt;# 安装需要依赖的库$ npm install 新建完成后，项目文件下的目录如下：12345678.├── _config.yml # 网站全局配置信息├── package.json # 应用程序信息├── scaffolds # 模板文件夹├── source # 资源文件存放用户资源，404 favicon CNAME 等都应该放在这里| ├── _drafts # 文稿| └── _posts # 文章└── themes # 主题文件夹 执行命令，启动本地服务器： 123456789$ cd &lt;folder&gt; # 切换到项目目录下$ npm install # install before start blogging$ hexo server # 运行本地服务,预览效果# 如果需要更改端口启动，或4000端口被占用$ hexo server [-p,--prot] 5000# 服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置$ hexo server -i 192.168.1.1 默认情况下，浏览器访问 http://localhost:4000/ 查看效果 修改 Hexo 主题Hexo的主题都是一些前端民间高手写的模版，可以在官方收录的主题中去挑选：英文访问、中文访问 下载主题后，将主题文件夹放入 themes/ 文件夹下 提示：某些主题需要安装额外的库，需要仔细查看主题开发者的文档说明！！！ 修改 Hexo 配置文件，打开根目录下的 _config.yml 文件，找到 theme 字段，修改其值为主题文件夹的名字 提示：_config.yml 文件的字段意义，及其他配置到官方文档查看。传送门 Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 1234---title: Hello Worlddata: 2017-04-05 16:00:00--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 静态文件生成器12345678$ cd &lt;folder&gt; # 切换到项目目录下# 生成文件到 publick/ 文件夹下$ hexo generate# 生成文件后部署, 二选一即可$ hexo generate --deploy # 简写：hexo g -d$ hexo deploy --generate # 简写：hexo d -g 部署 注册 码云 or GitHub 的账号 创建一个项目 获取项目地址 安装 hexo-deploy-git ，协助完成上传工作 12$ cd &lt;folder&gt; # 切换到项目文件下$ npm install hexo-deployer-git --save 配置项目根目录的 _config.yml 文件，修改 deploy 值 1234deploy: type: git repo: https://git.oschina.net/gitfuck99/blog.git # 项目地址 branch: master 执行部署 12$ cd &lt;folder&gt;$ hexo deploy 开启 码云Pages 功能 进入 git.oschina.net 的项目下，找到 Pages 选项卡，开启服务后进行访问 开启 GitHub Pages 功能 待添加","categories":[{"name":"未分类","slug":"未分类","permalink":"http://gavinluo.cn/blog/categories/未分类/"}],"tags":[{"name":"git pages","slug":"git-pages","permalink":"http://gavinluo.cn/blog/tags/git-pages/"}]},{"title":"Express","slug":"Express入门","date":"2016-10-22T14:40:00.000Z","updated":"2018-01-04T03:12:54.933Z","comments":true,"path":"2016/10/22/Express入门/","link":"","permalink":"http://gavinluo.cn/blog/2016/10/22/Express入门/","excerpt":"","text":"前言正文安装 首先确认已经安装了Node.js，接下来创建一个目录，然后进入改工作项目目录 12$ mkdir myapp$ cd myapp 执行 npm init 命令创建一个package.json文件。（了解package.json如何起作用，参考：Specifics of npm’s package.json handing.） 1$ npm init 执行初始化 npm 时，系统需要输入配置参数，可以全部直接按“回车”键，接默认设置. 安装 Express ，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。 1234# 临时安装 Express，不添加依赖列表中$ npm install express# 添加 --save ，将安装的 Express 添加到依赖列表中$ npm install express --save 示例代码 简单的几个路由 12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var app = express();// 网站首页访问app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;Hello World!&apos;);&#125;);// 网站首页接收 POST 请求app.post(&apos;/&apos;, function(req, res)&#123; res.send(&apos;Got a Post request&apos;);&#125;);// 节点 /user 接受 PUT 请求app.put(&apos;/user&apos;, function(req, res)&#123; res.send(&apos;Got a PUT request at /user&apos;);&#125;);// 节点 /user 接受 DELETE 请求app.delete(&apos;/user&apos;, function(req, res)&#123; res.send(&apos;Got a DELETE request at /user&apos;);&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); ==提示==：req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(‘data’, callback) 以及任何 Node 提供的方法。 启动应用 1$ npm app.js 快速创建Express的项目12#通过应用生成器工具 express 可以快速创建一个应用的骨架。$ npm install express-generator -g 123456789101112131415# -h 选项可以列出所有可用的命令行选项：$ express -h Usage: express [options] [dir] Options: -h, --help output usage information -V, --version output the version number -e, --ejs add ejs engine support (defaults to jade) --hbs add handlebars engine support -H, --hogan add hogan.js engine support -c, --css &lt;engine&gt; add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css) --git add .gitignore -f, --force force on non-empty directory 1234567891011121314151617181920#例如，下面的示例就是在当前工作目录下创建一个命名为 myapp 的应用。$ express myapp create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/public/javascripts create : myapp/public/images create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css create : myapp/views create : myapp/views/index.jade create : myapp/views/layout.jade create : myapp/views/error.jade create : myapp/bin create : myapp/bin/www 123# 然后安装所有依赖包：$ cd myapp $ npm install 12# 启动这个应用（MacOS 或 Linux 平台）：$ DEBUG=myapp npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 总结","categories":[],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://gavinluo.cn/blog/tags/NodeJs/"},{"name":"Express","slug":"Express","permalink":"http://gavinluo.cn/blog/tags/Express/"}]}]}